// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"base-website/ent/migrate"

	"base-website/ent/authcode"
	"base-website/ent/authrefreshtoken"
	"base-website/ent/authtoken"
	"base-website/ent/component"
	"base-website/ent/user"
	"base-website/ent/uservote"
	"base-website/ent/vote"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AuthCode is the client for interacting with the AuthCode builders.
	AuthCode *AuthCodeClient
	// AuthRefreshToken is the client for interacting with the AuthRefreshToken builders.
	AuthRefreshToken *AuthRefreshTokenClient
	// AuthToken is the client for interacting with the AuthToken builders.
	AuthToken *AuthTokenClient
	// Component is the client for interacting with the Component builders.
	Component *ComponentClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserVote is the client for interacting with the UserVote builders.
	UserVote *UserVoteClient
	// Vote is the client for interacting with the Vote builders.
	Vote *VoteClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AuthCode = NewAuthCodeClient(c.config)
	c.AuthRefreshToken = NewAuthRefreshTokenClient(c.config)
	c.AuthToken = NewAuthTokenClient(c.config)
	c.Component = NewComponentClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserVote = NewUserVoteClient(c.config)
	c.Vote = NewVoteClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		AuthCode:         NewAuthCodeClient(cfg),
		AuthRefreshToken: NewAuthRefreshTokenClient(cfg),
		AuthToken:        NewAuthTokenClient(cfg),
		Component:        NewComponentClient(cfg),
		User:             NewUserClient(cfg),
		UserVote:         NewUserVoteClient(cfg),
		Vote:             NewVoteClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		AuthCode:         NewAuthCodeClient(cfg),
		AuthRefreshToken: NewAuthRefreshTokenClient(cfg),
		AuthToken:        NewAuthTokenClient(cfg),
		Component:        NewComponentClient(cfg),
		User:             NewUserClient(cfg),
		UserVote:         NewUserVoteClient(cfg),
		Vote:             NewVoteClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AuthCode.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AuthCode, c.AuthRefreshToken, c.AuthToken, c.Component, c.User, c.UserVote,
		c.Vote,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AuthCode, c.AuthRefreshToken, c.AuthToken, c.Component, c.User, c.UserVote,
		c.Vote,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AuthCodeMutation:
		return c.AuthCode.mutate(ctx, m)
	case *AuthRefreshTokenMutation:
		return c.AuthRefreshToken.mutate(ctx, m)
	case *AuthTokenMutation:
		return c.AuthToken.mutate(ctx, m)
	case *ComponentMutation:
		return c.Component.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserVoteMutation:
		return c.UserVote.mutate(ctx, m)
	case *VoteMutation:
		return c.Vote.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AuthCodeClient is a client for the AuthCode schema.
type AuthCodeClient struct {
	config
}

// NewAuthCodeClient returns a client for the AuthCode from the given config.
func NewAuthCodeClient(c config) *AuthCodeClient {
	return &AuthCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authcode.Hooks(f(g(h())))`.
func (c *AuthCodeClient) Use(hooks ...Hook) {
	c.hooks.AuthCode = append(c.hooks.AuthCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authcode.Intercept(f(g(h())))`.
func (c *AuthCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthCode = append(c.inters.AuthCode, interceptors...)
}

// Create returns a builder for creating a AuthCode entity.
func (c *AuthCodeClient) Create() *AuthCodeCreate {
	mutation := newAuthCodeMutation(c.config, OpCreate)
	return &AuthCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthCode entities.
func (c *AuthCodeClient) CreateBulk(builders ...*AuthCodeCreate) *AuthCodeCreateBulk {
	return &AuthCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthCodeClient) MapCreateBulk(slice any, setFunc func(*AuthCodeCreate, int)) *AuthCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthCodeCreateBulk{err: fmt.Errorf("calling to AuthCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthCode.
func (c *AuthCodeClient) Update() *AuthCodeUpdate {
	mutation := newAuthCodeMutation(c.config, OpUpdate)
	return &AuthCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthCodeClient) UpdateOne(_m *AuthCode) *AuthCodeUpdateOne {
	mutation := newAuthCodeMutation(c.config, OpUpdateOne, withAuthCode(_m))
	return &AuthCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthCodeClient) UpdateOneID(id string) *AuthCodeUpdateOne {
	mutation := newAuthCodeMutation(c.config, OpUpdateOne, withAuthCodeID(id))
	return &AuthCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthCode.
func (c *AuthCodeClient) Delete() *AuthCodeDelete {
	mutation := newAuthCodeMutation(c.config, OpDelete)
	return &AuthCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthCodeClient) DeleteOne(_m *AuthCode) *AuthCodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthCodeClient) DeleteOneID(id string) *AuthCodeDeleteOne {
	builder := c.Delete().Where(authcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthCodeDeleteOne{builder}
}

// Query returns a query builder for AuthCode.
func (c *AuthCodeClient) Query() *AuthCodeQuery {
	return &AuthCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthCode},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthCode entity by its id.
func (c *AuthCodeClient) Get(ctx context.Context, id string) (*AuthCode, error) {
	return c.Query().Where(authcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthCodeClient) GetX(ctx context.Context, id string) *AuthCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthCodeClient) Hooks() []Hook {
	return c.hooks.AuthCode
}

// Interceptors returns the client interceptors.
func (c *AuthCodeClient) Interceptors() []Interceptor {
	return c.inters.AuthCode
}

func (c *AuthCodeClient) mutate(ctx context.Context, m *AuthCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthCode mutation op: %q", m.Op())
	}
}

// AuthRefreshTokenClient is a client for the AuthRefreshToken schema.
type AuthRefreshTokenClient struct {
	config
}

// NewAuthRefreshTokenClient returns a client for the AuthRefreshToken from the given config.
func NewAuthRefreshTokenClient(c config) *AuthRefreshTokenClient {
	return &AuthRefreshTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authrefreshtoken.Hooks(f(g(h())))`.
func (c *AuthRefreshTokenClient) Use(hooks ...Hook) {
	c.hooks.AuthRefreshToken = append(c.hooks.AuthRefreshToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authrefreshtoken.Intercept(f(g(h())))`.
func (c *AuthRefreshTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthRefreshToken = append(c.inters.AuthRefreshToken, interceptors...)
}

// Create returns a builder for creating a AuthRefreshToken entity.
func (c *AuthRefreshTokenClient) Create() *AuthRefreshTokenCreate {
	mutation := newAuthRefreshTokenMutation(c.config, OpCreate)
	return &AuthRefreshTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthRefreshToken entities.
func (c *AuthRefreshTokenClient) CreateBulk(builders ...*AuthRefreshTokenCreate) *AuthRefreshTokenCreateBulk {
	return &AuthRefreshTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthRefreshTokenClient) MapCreateBulk(slice any, setFunc func(*AuthRefreshTokenCreate, int)) *AuthRefreshTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthRefreshTokenCreateBulk{err: fmt.Errorf("calling to AuthRefreshTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthRefreshTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthRefreshTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthRefreshToken.
func (c *AuthRefreshTokenClient) Update() *AuthRefreshTokenUpdate {
	mutation := newAuthRefreshTokenMutation(c.config, OpUpdate)
	return &AuthRefreshTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthRefreshTokenClient) UpdateOne(_m *AuthRefreshToken) *AuthRefreshTokenUpdateOne {
	mutation := newAuthRefreshTokenMutation(c.config, OpUpdateOne, withAuthRefreshToken(_m))
	return &AuthRefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthRefreshTokenClient) UpdateOneID(id string) *AuthRefreshTokenUpdateOne {
	mutation := newAuthRefreshTokenMutation(c.config, OpUpdateOne, withAuthRefreshTokenID(id))
	return &AuthRefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthRefreshToken.
func (c *AuthRefreshTokenClient) Delete() *AuthRefreshTokenDelete {
	mutation := newAuthRefreshTokenMutation(c.config, OpDelete)
	return &AuthRefreshTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthRefreshTokenClient) DeleteOne(_m *AuthRefreshToken) *AuthRefreshTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthRefreshTokenClient) DeleteOneID(id string) *AuthRefreshTokenDeleteOne {
	builder := c.Delete().Where(authrefreshtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthRefreshTokenDeleteOne{builder}
}

// Query returns a query builder for AuthRefreshToken.
func (c *AuthRefreshTokenClient) Query() *AuthRefreshTokenQuery {
	return &AuthRefreshTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthRefreshToken},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthRefreshToken entity by its id.
func (c *AuthRefreshTokenClient) Get(ctx context.Context, id string) (*AuthRefreshToken, error) {
	return c.Query().Where(authrefreshtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthRefreshTokenClient) GetX(ctx context.Context, id string) *AuthRefreshToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthRefreshTokenClient) Hooks() []Hook {
	return c.hooks.AuthRefreshToken
}

// Interceptors returns the client interceptors.
func (c *AuthRefreshTokenClient) Interceptors() []Interceptor {
	return c.inters.AuthRefreshToken
}

func (c *AuthRefreshTokenClient) mutate(ctx context.Context, m *AuthRefreshTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthRefreshTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthRefreshTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthRefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthRefreshTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthRefreshToken mutation op: %q", m.Op())
	}
}

// AuthTokenClient is a client for the AuthToken schema.
type AuthTokenClient struct {
	config
}

// NewAuthTokenClient returns a client for the AuthToken from the given config.
func NewAuthTokenClient(c config) *AuthTokenClient {
	return &AuthTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authtoken.Hooks(f(g(h())))`.
func (c *AuthTokenClient) Use(hooks ...Hook) {
	c.hooks.AuthToken = append(c.hooks.AuthToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authtoken.Intercept(f(g(h())))`.
func (c *AuthTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthToken = append(c.inters.AuthToken, interceptors...)
}

// Create returns a builder for creating a AuthToken entity.
func (c *AuthTokenClient) Create() *AuthTokenCreate {
	mutation := newAuthTokenMutation(c.config, OpCreate)
	return &AuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthToken entities.
func (c *AuthTokenClient) CreateBulk(builders ...*AuthTokenCreate) *AuthTokenCreateBulk {
	return &AuthTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthTokenClient) MapCreateBulk(slice any, setFunc func(*AuthTokenCreate, int)) *AuthTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthTokenCreateBulk{err: fmt.Errorf("calling to AuthTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthToken.
func (c *AuthTokenClient) Update() *AuthTokenUpdate {
	mutation := newAuthTokenMutation(c.config, OpUpdate)
	return &AuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthTokenClient) UpdateOne(_m *AuthToken) *AuthTokenUpdateOne {
	mutation := newAuthTokenMutation(c.config, OpUpdateOne, withAuthToken(_m))
	return &AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthTokenClient) UpdateOneID(id string) *AuthTokenUpdateOne {
	mutation := newAuthTokenMutation(c.config, OpUpdateOne, withAuthTokenID(id))
	return &AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthToken.
func (c *AuthTokenClient) Delete() *AuthTokenDelete {
	mutation := newAuthTokenMutation(c.config, OpDelete)
	return &AuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthTokenClient) DeleteOne(_m *AuthToken) *AuthTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthTokenClient) DeleteOneID(id string) *AuthTokenDeleteOne {
	builder := c.Delete().Where(authtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthTokenDeleteOne{builder}
}

// Query returns a query builder for AuthToken.
func (c *AuthTokenClient) Query() *AuthTokenQuery {
	return &AuthTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthToken},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthToken entity by its id.
func (c *AuthTokenClient) Get(ctx context.Context, id string) (*AuthToken, error) {
	return c.Query().Where(authtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthTokenClient) GetX(ctx context.Context, id string) *AuthToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthTokenClient) Hooks() []Hook {
	return c.hooks.AuthToken
}

// Interceptors returns the client interceptors.
func (c *AuthTokenClient) Interceptors() []Interceptor {
	return c.inters.AuthToken
}

func (c *AuthTokenClient) mutate(ctx context.Context, m *AuthTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthToken mutation op: %q", m.Op())
	}
}

// ComponentClient is a client for the Component schema.
type ComponentClient struct {
	config
}

// NewComponentClient returns a client for the Component from the given config.
func NewComponentClient(c config) *ComponentClient {
	return &ComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `component.Hooks(f(g(h())))`.
func (c *ComponentClient) Use(hooks ...Hook) {
	c.hooks.Component = append(c.hooks.Component, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `component.Intercept(f(g(h())))`.
func (c *ComponentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Component = append(c.inters.Component, interceptors...)
}

// Create returns a builder for creating a Component entity.
func (c *ComponentClient) Create() *ComponentCreate {
	mutation := newComponentMutation(c.config, OpCreate)
	return &ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Component entities.
func (c *ComponentClient) CreateBulk(builders ...*ComponentCreate) *ComponentCreateBulk {
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ComponentClient) MapCreateBulk(slice any, setFunc func(*ComponentCreate, int)) *ComponentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ComponentCreateBulk{err: fmt.Errorf("calling to ComponentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ComponentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Component.
func (c *ComponentClient) Update() *ComponentUpdate {
	mutation := newComponentMutation(c.config, OpUpdate)
	return &ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ComponentClient) UpdateOne(_m *Component) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponent(_m))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ComponentClient) UpdateOneID(id int) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponentID(id))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Component.
func (c *ComponentClient) Delete() *ComponentDelete {
	mutation := newComponentMutation(c.config, OpDelete)
	return &ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ComponentClient) DeleteOne(_m *Component) *ComponentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ComponentClient) DeleteOneID(id int) *ComponentDeleteOne {
	builder := c.Delete().Where(component.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ComponentDeleteOne{builder}
}

// Query returns a query builder for Component.
func (c *ComponentClient) Query() *ComponentQuery {
	return &ComponentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComponent},
		inters: c.Interceptors(),
	}
}

// Get returns a Component entity by its id.
func (c *ComponentClient) Get(ctx context.Context, id int) (*Component, error) {
	return c.Query().Where(component.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ComponentClient) GetX(ctx context.Context, id int) *Component {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVote queries the vote edge of a Component.
func (c *ComponentClient) QueryVote(_m *Component) *VoteQuery {
	query := (&VoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(vote.Table, vote.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, component.VoteTable, component.VoteColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserVotes queries the user_votes edge of a Component.
func (c *ComponentClient) QueryUserVotes(_m *Component) *UserVoteQuery {
	query := (&UserVoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(uservote.Table, uservote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, component.UserVotesTable, component.UserVotesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ComponentClient) Hooks() []Hook {
	return c.hooks.Component
}

// Interceptors returns the client interceptors.
func (c *ComponentClient) Interceptors() []Interceptor {
	return c.inters.Component
}

func (c *ComponentClient) mutate(ctx context.Context, m *ComponentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Component mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserVotes queries the user_votes edge of a User.
func (c *UserClient) QueryUserVotes(_m *User) *UserVoteQuery {
	query := (&UserVoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(uservote.Table, uservote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserVotesTable, user.UserVotesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserVoteClient is a client for the UserVote schema.
type UserVoteClient struct {
	config
}

// NewUserVoteClient returns a client for the UserVote from the given config.
func NewUserVoteClient(c config) *UserVoteClient {
	return &UserVoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `uservote.Hooks(f(g(h())))`.
func (c *UserVoteClient) Use(hooks ...Hook) {
	c.hooks.UserVote = append(c.hooks.UserVote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `uservote.Intercept(f(g(h())))`.
func (c *UserVoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserVote = append(c.inters.UserVote, interceptors...)
}

// Create returns a builder for creating a UserVote entity.
func (c *UserVoteClient) Create() *UserVoteCreate {
	mutation := newUserVoteMutation(c.config, OpCreate)
	return &UserVoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserVote entities.
func (c *UserVoteClient) CreateBulk(builders ...*UserVoteCreate) *UserVoteCreateBulk {
	return &UserVoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserVoteClient) MapCreateBulk(slice any, setFunc func(*UserVoteCreate, int)) *UserVoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserVoteCreateBulk{err: fmt.Errorf("calling to UserVoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserVoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserVoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserVote.
func (c *UserVoteClient) Update() *UserVoteUpdate {
	mutation := newUserVoteMutation(c.config, OpUpdate)
	return &UserVoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserVoteClient) UpdateOne(_m *UserVote) *UserVoteUpdateOne {
	mutation := newUserVoteMutation(c.config, OpUpdateOne, withUserVote(_m))
	return &UserVoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserVoteClient) UpdateOneID(id int) *UserVoteUpdateOne {
	mutation := newUserVoteMutation(c.config, OpUpdateOne, withUserVoteID(id))
	return &UserVoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserVote.
func (c *UserVoteClient) Delete() *UserVoteDelete {
	mutation := newUserVoteMutation(c.config, OpDelete)
	return &UserVoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserVoteClient) DeleteOne(_m *UserVote) *UserVoteDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserVoteClient) DeleteOneID(id int) *UserVoteDeleteOne {
	builder := c.Delete().Where(uservote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserVoteDeleteOne{builder}
}

// Query returns a query builder for UserVote.
func (c *UserVoteClient) Query() *UserVoteQuery {
	return &UserVoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserVote},
		inters: c.Interceptors(),
	}
}

// Get returns a UserVote entity by its id.
func (c *UserVoteClient) Get(ctx context.Context, id int) (*UserVote, error) {
	return c.Query().Where(uservote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserVoteClient) GetX(ctx context.Context, id int) *UserVote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserVote.
func (c *UserVoteClient) QueryUser(_m *UserVote) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(uservote.Table, uservote.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, uservote.UserTable, uservote.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponent queries the component edge of a UserVote.
func (c *UserVoteClient) QueryComponent(_m *UserVote) *ComponentQuery {
	query := (&ComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(uservote.Table, uservote.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, uservote.ComponentTable, uservote.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserVoteClient) Hooks() []Hook {
	return c.hooks.UserVote
}

// Interceptors returns the client interceptors.
func (c *UserVoteClient) Interceptors() []Interceptor {
	return c.inters.UserVote
}

func (c *UserVoteClient) mutate(ctx context.Context, m *UserVoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserVoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserVoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserVoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserVoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserVote mutation op: %q", m.Op())
	}
}

// VoteClient is a client for the Vote schema.
type VoteClient struct {
	config
}

// NewVoteClient returns a client for the Vote from the given config.
func NewVoteClient(c config) *VoteClient {
	return &VoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vote.Hooks(f(g(h())))`.
func (c *VoteClient) Use(hooks ...Hook) {
	c.hooks.Vote = append(c.hooks.Vote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vote.Intercept(f(g(h())))`.
func (c *VoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Vote = append(c.inters.Vote, interceptors...)
}

// Create returns a builder for creating a Vote entity.
func (c *VoteClient) Create() *VoteCreate {
	mutation := newVoteMutation(c.config, OpCreate)
	return &VoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vote entities.
func (c *VoteClient) CreateBulk(builders ...*VoteCreate) *VoteCreateBulk {
	return &VoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VoteClient) MapCreateBulk(slice any, setFunc func(*VoteCreate, int)) *VoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VoteCreateBulk{err: fmt.Errorf("calling to VoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vote.
func (c *VoteClient) Update() *VoteUpdate {
	mutation := newVoteMutation(c.config, OpUpdate)
	return &VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VoteClient) UpdateOne(_m *Vote) *VoteUpdateOne {
	mutation := newVoteMutation(c.config, OpUpdateOne, withVote(_m))
	return &VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VoteClient) UpdateOneID(id int) *VoteUpdateOne {
	mutation := newVoteMutation(c.config, OpUpdateOne, withVoteID(id))
	return &VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vote.
func (c *VoteClient) Delete() *VoteDelete {
	mutation := newVoteMutation(c.config, OpDelete)
	return &VoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VoteClient) DeleteOne(_m *Vote) *VoteDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VoteClient) DeleteOneID(id int) *VoteDeleteOne {
	builder := c.Delete().Where(vote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VoteDeleteOne{builder}
}

// Query returns a query builder for Vote.
func (c *VoteClient) Query() *VoteQuery {
	return &VoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVote},
		inters: c.Interceptors(),
	}
}

// Get returns a Vote entity by its id.
func (c *VoteClient) Get(ctx context.Context, id int) (*Vote, error) {
	return c.Query().Where(vote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VoteClient) GetX(ctx context.Context, id int) *Vote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponents queries the components edge of a Vote.
func (c *VoteClient) QueryComponents(_m *Vote) *ComponentQuery {
	query := (&ComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vote.Table, vote.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vote.ComponentsTable, vote.ComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VoteClient) Hooks() []Hook {
	return c.hooks.Vote
}

// Interceptors returns the client interceptors.
func (c *VoteClient) Interceptors() []Interceptor {
	return c.inters.Vote
}

func (c *VoteClient) mutate(ctx context.Context, m *VoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Vote mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AuthCode, AuthRefreshToken, AuthToken, Component, User, UserVote,
		Vote []ent.Hook
	}
	inters struct {
		AuthCode, AuthRefreshToken, AuthToken, Component, User, UserVote,
		Vote []ent.Interceptor
	}
)
