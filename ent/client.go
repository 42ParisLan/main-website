// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"base-website/ent/migrate"

	"base-website/ent/app"
	"base-website/ent/authcode"
	"base-website/ent/authrefreshtoken"
	"base-website/ent/authtoken"
	"base-website/ent/component"
	"base-website/ent/consent"
	"base-website/ent/invitation"
	"base-website/ent/rankgroup"
	"base-website/ent/team"
	"base-website/ent/teammember"
	"base-website/ent/tournament"
	"base-website/ent/tournamentadmin"
	"base-website/ent/user"
	"base-website/ent/uservote"
	"base-website/ent/vote"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// App is the client for interacting with the App builders.
	App *AppClient
	// AuthCode is the client for interacting with the AuthCode builders.
	AuthCode *AuthCodeClient
	// AuthRefreshToken is the client for interacting with the AuthRefreshToken builders.
	AuthRefreshToken *AuthRefreshTokenClient
	// AuthToken is the client for interacting with the AuthToken builders.
	AuthToken *AuthTokenClient
	// Component is the client for interacting with the Component builders.
	Component *ComponentClient
	// Consent is the client for interacting with the Consent builders.
	Consent *ConsentClient
	// Invitation is the client for interacting with the Invitation builders.
	Invitation *InvitationClient
	// RankGroup is the client for interacting with the RankGroup builders.
	RankGroup *RankGroupClient
	// Team is the client for interacting with the Team builders.
	Team *TeamClient
	// TeamMember is the client for interacting with the TeamMember builders.
	TeamMember *TeamMemberClient
	// Tournament is the client for interacting with the Tournament builders.
	Tournament *TournamentClient
	// TournamentAdmin is the client for interacting with the TournamentAdmin builders.
	TournamentAdmin *TournamentAdminClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// UserVote is the client for interacting with the UserVote builders.
	UserVote *UserVoteClient
	// Vote is the client for interacting with the Vote builders.
	Vote *VoteClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.App = NewAppClient(c.config)
	c.AuthCode = NewAuthCodeClient(c.config)
	c.AuthRefreshToken = NewAuthRefreshTokenClient(c.config)
	c.AuthToken = NewAuthTokenClient(c.config)
	c.Component = NewComponentClient(c.config)
	c.Consent = NewConsentClient(c.config)
	c.Invitation = NewInvitationClient(c.config)
	c.RankGroup = NewRankGroupClient(c.config)
	c.Team = NewTeamClient(c.config)
	c.TeamMember = NewTeamMemberClient(c.config)
	c.Tournament = NewTournamentClient(c.config)
	c.TournamentAdmin = NewTournamentAdminClient(c.config)
	c.User = NewUserClient(c.config)
	c.UserVote = NewUserVoteClient(c.config)
	c.Vote = NewVoteClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		App:              NewAppClient(cfg),
		AuthCode:         NewAuthCodeClient(cfg),
		AuthRefreshToken: NewAuthRefreshTokenClient(cfg),
		AuthToken:        NewAuthTokenClient(cfg),
		Component:        NewComponentClient(cfg),
		Consent:          NewConsentClient(cfg),
		Invitation:       NewInvitationClient(cfg),
		RankGroup:        NewRankGroupClient(cfg),
		Team:             NewTeamClient(cfg),
		TeamMember:       NewTeamMemberClient(cfg),
		Tournament:       NewTournamentClient(cfg),
		TournamentAdmin:  NewTournamentAdminClient(cfg),
		User:             NewUserClient(cfg),
		UserVote:         NewUserVoteClient(cfg),
		Vote:             NewVoteClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		App:              NewAppClient(cfg),
		AuthCode:         NewAuthCodeClient(cfg),
		AuthRefreshToken: NewAuthRefreshTokenClient(cfg),
		AuthToken:        NewAuthTokenClient(cfg),
		Component:        NewComponentClient(cfg),
		Consent:          NewConsentClient(cfg),
		Invitation:       NewInvitationClient(cfg),
		RankGroup:        NewRankGroupClient(cfg),
		Team:             NewTeamClient(cfg),
		TeamMember:       NewTeamMemberClient(cfg),
		Tournament:       NewTournamentClient(cfg),
		TournamentAdmin:  NewTournamentAdminClient(cfg),
		User:             NewUserClient(cfg),
		UserVote:         NewUserVoteClient(cfg),
		Vote:             NewVoteClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		App.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.App, c.AuthCode, c.AuthRefreshToken, c.AuthToken, c.Component, c.Consent,
		c.Invitation, c.RankGroup, c.Team, c.TeamMember, c.Tournament,
		c.TournamentAdmin, c.User, c.UserVote, c.Vote,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.App, c.AuthCode, c.AuthRefreshToken, c.AuthToken, c.Component, c.Consent,
		c.Invitation, c.RankGroup, c.Team, c.TeamMember, c.Tournament,
		c.TournamentAdmin, c.User, c.UserVote, c.Vote,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AppMutation:
		return c.App.mutate(ctx, m)
	case *AuthCodeMutation:
		return c.AuthCode.mutate(ctx, m)
	case *AuthRefreshTokenMutation:
		return c.AuthRefreshToken.mutate(ctx, m)
	case *AuthTokenMutation:
		return c.AuthToken.mutate(ctx, m)
	case *ComponentMutation:
		return c.Component.mutate(ctx, m)
	case *ConsentMutation:
		return c.Consent.mutate(ctx, m)
	case *InvitationMutation:
		return c.Invitation.mutate(ctx, m)
	case *RankGroupMutation:
		return c.RankGroup.mutate(ctx, m)
	case *TeamMutation:
		return c.Team.mutate(ctx, m)
	case *TeamMemberMutation:
		return c.TeamMember.mutate(ctx, m)
	case *TournamentMutation:
		return c.Tournament.mutate(ctx, m)
	case *TournamentAdminMutation:
		return c.TournamentAdmin.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *UserVoteMutation:
		return c.UserVote.mutate(ctx, m)
	case *VoteMutation:
		return c.Vote.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `app.Intercept(f(g(h())))`.
func (c *AppClient) Intercept(interceptors ...Interceptor) {
	c.inters.App = append(c.inters.App, interceptors...)
}

// Create returns a builder for creating a App entity.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppClient) MapCreateBulk(slice any, setFunc func(*AppCreate, int)) *AppCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppCreateBulk{err: fmt.Errorf("calling to AppClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(_m *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(_m))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id string) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppClient) DeleteOne(_m *App) *AppDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppClient) DeleteOneID(id string) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApp},
		inters: c.Interceptors(),
	}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id string) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id string) *App {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryOwner queries the owner edge of a App.
func (c *AppClient) QueryOwner(_m *App) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, app.OwnerTable, app.OwnerColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConsents queries the consents edge of a App.
func (c *AppClient) QueryConsents(_m *App) *ConsentQuery {
	query := (&ConsentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(consent.Table, consent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, app.ConsentsTable, app.ConsentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	return c.hooks.App
}

// Interceptors returns the client interceptors.
func (c *AppClient) Interceptors() []Interceptor {
	return c.inters.App
}

func (c *AppClient) mutate(ctx context.Context, m *AppMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown App mutation op: %q", m.Op())
	}
}

// AuthCodeClient is a client for the AuthCode schema.
type AuthCodeClient struct {
	config
}

// NewAuthCodeClient returns a client for the AuthCode from the given config.
func NewAuthCodeClient(c config) *AuthCodeClient {
	return &AuthCodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authcode.Hooks(f(g(h())))`.
func (c *AuthCodeClient) Use(hooks ...Hook) {
	c.hooks.AuthCode = append(c.hooks.AuthCode, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authcode.Intercept(f(g(h())))`.
func (c *AuthCodeClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthCode = append(c.inters.AuthCode, interceptors...)
}

// Create returns a builder for creating a AuthCode entity.
func (c *AuthCodeClient) Create() *AuthCodeCreate {
	mutation := newAuthCodeMutation(c.config, OpCreate)
	return &AuthCodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthCode entities.
func (c *AuthCodeClient) CreateBulk(builders ...*AuthCodeCreate) *AuthCodeCreateBulk {
	return &AuthCodeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthCodeClient) MapCreateBulk(slice any, setFunc func(*AuthCodeCreate, int)) *AuthCodeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthCodeCreateBulk{err: fmt.Errorf("calling to AuthCodeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthCodeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthCodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthCode.
func (c *AuthCodeClient) Update() *AuthCodeUpdate {
	mutation := newAuthCodeMutation(c.config, OpUpdate)
	return &AuthCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthCodeClient) UpdateOne(_m *AuthCode) *AuthCodeUpdateOne {
	mutation := newAuthCodeMutation(c.config, OpUpdateOne, withAuthCode(_m))
	return &AuthCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthCodeClient) UpdateOneID(id string) *AuthCodeUpdateOne {
	mutation := newAuthCodeMutation(c.config, OpUpdateOne, withAuthCodeID(id))
	return &AuthCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthCode.
func (c *AuthCodeClient) Delete() *AuthCodeDelete {
	mutation := newAuthCodeMutation(c.config, OpDelete)
	return &AuthCodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthCodeClient) DeleteOne(_m *AuthCode) *AuthCodeDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthCodeClient) DeleteOneID(id string) *AuthCodeDeleteOne {
	builder := c.Delete().Where(authcode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthCodeDeleteOne{builder}
}

// Query returns a query builder for AuthCode.
func (c *AuthCodeClient) Query() *AuthCodeQuery {
	return &AuthCodeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthCode},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthCode entity by its id.
func (c *AuthCodeClient) Get(ctx context.Context, id string) (*AuthCode, error) {
	return c.Query().Where(authcode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthCodeClient) GetX(ctx context.Context, id string) *AuthCode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthCodeClient) Hooks() []Hook {
	return c.hooks.AuthCode
}

// Interceptors returns the client interceptors.
func (c *AuthCodeClient) Interceptors() []Interceptor {
	return c.inters.AuthCode
}

func (c *AuthCodeClient) mutate(ctx context.Context, m *AuthCodeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthCodeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthCodeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthCodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthCodeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthCode mutation op: %q", m.Op())
	}
}

// AuthRefreshTokenClient is a client for the AuthRefreshToken schema.
type AuthRefreshTokenClient struct {
	config
}

// NewAuthRefreshTokenClient returns a client for the AuthRefreshToken from the given config.
func NewAuthRefreshTokenClient(c config) *AuthRefreshTokenClient {
	return &AuthRefreshTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authrefreshtoken.Hooks(f(g(h())))`.
func (c *AuthRefreshTokenClient) Use(hooks ...Hook) {
	c.hooks.AuthRefreshToken = append(c.hooks.AuthRefreshToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authrefreshtoken.Intercept(f(g(h())))`.
func (c *AuthRefreshTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthRefreshToken = append(c.inters.AuthRefreshToken, interceptors...)
}

// Create returns a builder for creating a AuthRefreshToken entity.
func (c *AuthRefreshTokenClient) Create() *AuthRefreshTokenCreate {
	mutation := newAuthRefreshTokenMutation(c.config, OpCreate)
	return &AuthRefreshTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthRefreshToken entities.
func (c *AuthRefreshTokenClient) CreateBulk(builders ...*AuthRefreshTokenCreate) *AuthRefreshTokenCreateBulk {
	return &AuthRefreshTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthRefreshTokenClient) MapCreateBulk(slice any, setFunc func(*AuthRefreshTokenCreate, int)) *AuthRefreshTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthRefreshTokenCreateBulk{err: fmt.Errorf("calling to AuthRefreshTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthRefreshTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthRefreshTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthRefreshToken.
func (c *AuthRefreshTokenClient) Update() *AuthRefreshTokenUpdate {
	mutation := newAuthRefreshTokenMutation(c.config, OpUpdate)
	return &AuthRefreshTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthRefreshTokenClient) UpdateOne(_m *AuthRefreshToken) *AuthRefreshTokenUpdateOne {
	mutation := newAuthRefreshTokenMutation(c.config, OpUpdateOne, withAuthRefreshToken(_m))
	return &AuthRefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthRefreshTokenClient) UpdateOneID(id string) *AuthRefreshTokenUpdateOne {
	mutation := newAuthRefreshTokenMutation(c.config, OpUpdateOne, withAuthRefreshTokenID(id))
	return &AuthRefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthRefreshToken.
func (c *AuthRefreshTokenClient) Delete() *AuthRefreshTokenDelete {
	mutation := newAuthRefreshTokenMutation(c.config, OpDelete)
	return &AuthRefreshTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthRefreshTokenClient) DeleteOne(_m *AuthRefreshToken) *AuthRefreshTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthRefreshTokenClient) DeleteOneID(id string) *AuthRefreshTokenDeleteOne {
	builder := c.Delete().Where(authrefreshtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthRefreshTokenDeleteOne{builder}
}

// Query returns a query builder for AuthRefreshToken.
func (c *AuthRefreshTokenClient) Query() *AuthRefreshTokenQuery {
	return &AuthRefreshTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthRefreshToken},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthRefreshToken entity by its id.
func (c *AuthRefreshTokenClient) Get(ctx context.Context, id string) (*AuthRefreshToken, error) {
	return c.Query().Where(authrefreshtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthRefreshTokenClient) GetX(ctx context.Context, id string) *AuthRefreshToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthRefreshTokenClient) Hooks() []Hook {
	return c.hooks.AuthRefreshToken
}

// Interceptors returns the client interceptors.
func (c *AuthRefreshTokenClient) Interceptors() []Interceptor {
	return c.inters.AuthRefreshToken
}

func (c *AuthRefreshTokenClient) mutate(ctx context.Context, m *AuthRefreshTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthRefreshTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthRefreshTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthRefreshTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthRefreshTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthRefreshToken mutation op: %q", m.Op())
	}
}

// AuthTokenClient is a client for the AuthToken schema.
type AuthTokenClient struct {
	config
}

// NewAuthTokenClient returns a client for the AuthToken from the given config.
func NewAuthTokenClient(c config) *AuthTokenClient {
	return &AuthTokenClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `authtoken.Hooks(f(g(h())))`.
func (c *AuthTokenClient) Use(hooks ...Hook) {
	c.hooks.AuthToken = append(c.hooks.AuthToken, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `authtoken.Intercept(f(g(h())))`.
func (c *AuthTokenClient) Intercept(interceptors ...Interceptor) {
	c.inters.AuthToken = append(c.inters.AuthToken, interceptors...)
}

// Create returns a builder for creating a AuthToken entity.
func (c *AuthTokenClient) Create() *AuthTokenCreate {
	mutation := newAuthTokenMutation(c.config, OpCreate)
	return &AuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AuthToken entities.
func (c *AuthTokenClient) CreateBulk(builders ...*AuthTokenCreate) *AuthTokenCreateBulk {
	return &AuthTokenCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AuthTokenClient) MapCreateBulk(slice any, setFunc func(*AuthTokenCreate, int)) *AuthTokenCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AuthTokenCreateBulk{err: fmt.Errorf("calling to AuthTokenClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AuthTokenCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AuthTokenCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AuthToken.
func (c *AuthTokenClient) Update() *AuthTokenUpdate {
	mutation := newAuthTokenMutation(c.config, OpUpdate)
	return &AuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AuthTokenClient) UpdateOne(_m *AuthToken) *AuthTokenUpdateOne {
	mutation := newAuthTokenMutation(c.config, OpUpdateOne, withAuthToken(_m))
	return &AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AuthTokenClient) UpdateOneID(id string) *AuthTokenUpdateOne {
	mutation := newAuthTokenMutation(c.config, OpUpdateOne, withAuthTokenID(id))
	return &AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AuthToken.
func (c *AuthTokenClient) Delete() *AuthTokenDelete {
	mutation := newAuthTokenMutation(c.config, OpDelete)
	return &AuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AuthTokenClient) DeleteOne(_m *AuthToken) *AuthTokenDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AuthTokenClient) DeleteOneID(id string) *AuthTokenDeleteOne {
	builder := c.Delete().Where(authtoken.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AuthTokenDeleteOne{builder}
}

// Query returns a query builder for AuthToken.
func (c *AuthTokenClient) Query() *AuthTokenQuery {
	return &AuthTokenQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAuthToken},
		inters: c.Interceptors(),
	}
}

// Get returns a AuthToken entity by its id.
func (c *AuthTokenClient) Get(ctx context.Context, id string) (*AuthToken, error) {
	return c.Query().Where(authtoken.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AuthTokenClient) GetX(ctx context.Context, id string) *AuthToken {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AuthTokenClient) Hooks() []Hook {
	return c.hooks.AuthToken
}

// Interceptors returns the client interceptors.
func (c *AuthTokenClient) Interceptors() []Interceptor {
	return c.inters.AuthToken
}

func (c *AuthTokenClient) mutate(ctx context.Context, m *AuthTokenMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AuthTokenCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AuthTokenUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AuthTokenUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AuthTokenDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AuthToken mutation op: %q", m.Op())
	}
}

// ComponentClient is a client for the Component schema.
type ComponentClient struct {
	config
}

// NewComponentClient returns a client for the Component from the given config.
func NewComponentClient(c config) *ComponentClient {
	return &ComponentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `component.Hooks(f(g(h())))`.
func (c *ComponentClient) Use(hooks ...Hook) {
	c.hooks.Component = append(c.hooks.Component, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `component.Intercept(f(g(h())))`.
func (c *ComponentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Component = append(c.inters.Component, interceptors...)
}

// Create returns a builder for creating a Component entity.
func (c *ComponentClient) Create() *ComponentCreate {
	mutation := newComponentMutation(c.config, OpCreate)
	return &ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Component entities.
func (c *ComponentClient) CreateBulk(builders ...*ComponentCreate) *ComponentCreateBulk {
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ComponentClient) MapCreateBulk(slice any, setFunc func(*ComponentCreate, int)) *ComponentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ComponentCreateBulk{err: fmt.Errorf("calling to ComponentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ComponentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ComponentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Component.
func (c *ComponentClient) Update() *ComponentUpdate {
	mutation := newComponentMutation(c.config, OpUpdate)
	return &ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ComponentClient) UpdateOne(_m *Component) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponent(_m))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ComponentClient) UpdateOneID(id int) *ComponentUpdateOne {
	mutation := newComponentMutation(c.config, OpUpdateOne, withComponentID(id))
	return &ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Component.
func (c *ComponentClient) Delete() *ComponentDelete {
	mutation := newComponentMutation(c.config, OpDelete)
	return &ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ComponentClient) DeleteOne(_m *Component) *ComponentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ComponentClient) DeleteOneID(id int) *ComponentDeleteOne {
	builder := c.Delete().Where(component.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ComponentDeleteOne{builder}
}

// Query returns a query builder for Component.
func (c *ComponentClient) Query() *ComponentQuery {
	return &ComponentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeComponent},
		inters: c.Interceptors(),
	}
}

// Get returns a Component entity by its id.
func (c *ComponentClient) Get(ctx context.Context, id int) (*Component, error) {
	return c.Query().Where(component.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ComponentClient) GetX(ctx context.Context, id int) *Component {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVote queries the vote edge of a Component.
func (c *ComponentClient) QueryVote(_m *Component) *VoteQuery {
	query := (&VoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(vote.Table, vote.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, component.VoteTable, component.VoteColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUserVotes queries the user_votes edge of a Component.
func (c *ComponentClient) QueryUserVotes(_m *Component) *UserVoteQuery {
	query := (&UserVoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(component.Table, component.FieldID, id),
			sqlgraph.To(uservote.Table, uservote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, component.UserVotesTable, component.UserVotesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ComponentClient) Hooks() []Hook {
	return c.hooks.Component
}

// Interceptors returns the client interceptors.
func (c *ComponentClient) Interceptors() []Interceptor {
	return c.inters.Component
}

func (c *ComponentClient) mutate(ctx context.Context, m *ComponentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ComponentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ComponentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ComponentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ComponentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Component mutation op: %q", m.Op())
	}
}

// ConsentClient is a client for the Consent schema.
type ConsentClient struct {
	config
}

// NewConsentClient returns a client for the Consent from the given config.
func NewConsentClient(c config) *ConsentClient {
	return &ConsentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `consent.Hooks(f(g(h())))`.
func (c *ConsentClient) Use(hooks ...Hook) {
	c.hooks.Consent = append(c.hooks.Consent, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `consent.Intercept(f(g(h())))`.
func (c *ConsentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Consent = append(c.inters.Consent, interceptors...)
}

// Create returns a builder for creating a Consent entity.
func (c *ConsentClient) Create() *ConsentCreate {
	mutation := newConsentMutation(c.config, OpCreate)
	return &ConsentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Consent entities.
func (c *ConsentClient) CreateBulk(builders ...*ConsentCreate) *ConsentCreateBulk {
	return &ConsentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ConsentClient) MapCreateBulk(slice any, setFunc func(*ConsentCreate, int)) *ConsentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ConsentCreateBulk{err: fmt.Errorf("calling to ConsentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ConsentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ConsentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Consent.
func (c *ConsentClient) Update() *ConsentUpdate {
	mutation := newConsentMutation(c.config, OpUpdate)
	return &ConsentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ConsentClient) UpdateOne(_m *Consent) *ConsentUpdateOne {
	mutation := newConsentMutation(c.config, OpUpdateOne, withConsent(_m))
	return &ConsentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ConsentClient) UpdateOneID(id int) *ConsentUpdateOne {
	mutation := newConsentMutation(c.config, OpUpdateOne, withConsentID(id))
	return &ConsentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Consent.
func (c *ConsentClient) Delete() *ConsentDelete {
	mutation := newConsentMutation(c.config, OpDelete)
	return &ConsentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ConsentClient) DeleteOne(_m *Consent) *ConsentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ConsentClient) DeleteOneID(id int) *ConsentDeleteOne {
	builder := c.Delete().Where(consent.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ConsentDeleteOne{builder}
}

// Query returns a query builder for Consent.
func (c *ConsentClient) Query() *ConsentQuery {
	return &ConsentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeConsent},
		inters: c.Interceptors(),
	}
}

// Get returns a Consent entity by its id.
func (c *ConsentClient) Get(ctx context.Context, id int) (*Consent, error) {
	return c.Query().Where(consent.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ConsentClient) GetX(ctx context.Context, id int) *Consent {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryApplication queries the application edge of a Consent.
func (c *ConsentClient) QueryApplication(_m *Consent) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(consent.Table, consent.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, consent.ApplicationTable, consent.ApplicationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUser queries the user edge of a Consent.
func (c *ConsentClient) QueryUser(_m *Consent) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(consent.Table, consent.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, consent.UserTable, consent.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ConsentClient) Hooks() []Hook {
	return c.hooks.Consent
}

// Interceptors returns the client interceptors.
func (c *ConsentClient) Interceptors() []Interceptor {
	return c.inters.Consent
}

func (c *ConsentClient) mutate(ctx context.Context, m *ConsentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ConsentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ConsentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ConsentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ConsentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Consent mutation op: %q", m.Op())
	}
}

// InvitationClient is a client for the Invitation schema.
type InvitationClient struct {
	config
}

// NewInvitationClient returns a client for the Invitation from the given config.
func NewInvitationClient(c config) *InvitationClient {
	return &InvitationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `invitation.Hooks(f(g(h())))`.
func (c *InvitationClient) Use(hooks ...Hook) {
	c.hooks.Invitation = append(c.hooks.Invitation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `invitation.Intercept(f(g(h())))`.
func (c *InvitationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Invitation = append(c.inters.Invitation, interceptors...)
}

// Create returns a builder for creating a Invitation entity.
func (c *InvitationClient) Create() *InvitationCreate {
	mutation := newInvitationMutation(c.config, OpCreate)
	return &InvitationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Invitation entities.
func (c *InvitationClient) CreateBulk(builders ...*InvitationCreate) *InvitationCreateBulk {
	return &InvitationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *InvitationClient) MapCreateBulk(slice any, setFunc func(*InvitationCreate, int)) *InvitationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &InvitationCreateBulk{err: fmt.Errorf("calling to InvitationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*InvitationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &InvitationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Invitation.
func (c *InvitationClient) Update() *InvitationUpdate {
	mutation := newInvitationMutation(c.config, OpUpdate)
	return &InvitationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InvitationClient) UpdateOne(_m *Invitation) *InvitationUpdateOne {
	mutation := newInvitationMutation(c.config, OpUpdateOne, withInvitation(_m))
	return &InvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InvitationClient) UpdateOneID(id int) *InvitationUpdateOne {
	mutation := newInvitationMutation(c.config, OpUpdateOne, withInvitationID(id))
	return &InvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Invitation.
func (c *InvitationClient) Delete() *InvitationDelete {
	mutation := newInvitationMutation(c.config, OpDelete)
	return &InvitationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InvitationClient) DeleteOne(_m *Invitation) *InvitationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InvitationClient) DeleteOneID(id int) *InvitationDeleteOne {
	builder := c.Delete().Where(invitation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InvitationDeleteOne{builder}
}

// Query returns a query builder for Invitation.
func (c *InvitationClient) Query() *InvitationQuery {
	return &InvitationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInvitation},
		inters: c.Interceptors(),
	}
}

// Get returns a Invitation entity by its id.
func (c *InvitationClient) Get(ctx context.Context, id int) (*Invitation, error) {
	return c.Query().Where(invitation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InvitationClient) GetX(ctx context.Context, id int) *Invitation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTeam queries the team edge of a Invitation.
func (c *InvitationClient) QueryTeam(_m *Invitation) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invitation.Table, invitation.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invitation.TeamTable, invitation.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvitee queries the invitee edge of a Invitation.
func (c *InvitationClient) QueryInvitee(_m *Invitation) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(invitation.Table, invitation.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, invitation.InviteeTable, invitation.InviteeColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InvitationClient) Hooks() []Hook {
	return c.hooks.Invitation
}

// Interceptors returns the client interceptors.
func (c *InvitationClient) Interceptors() []Interceptor {
	return c.inters.Invitation
}

func (c *InvitationClient) mutate(ctx context.Context, m *InvitationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InvitationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InvitationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InvitationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InvitationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Invitation mutation op: %q", m.Op())
	}
}

// RankGroupClient is a client for the RankGroup schema.
type RankGroupClient struct {
	config
}

// NewRankGroupClient returns a client for the RankGroup from the given config.
func NewRankGroupClient(c config) *RankGroupClient {
	return &RankGroupClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `rankgroup.Hooks(f(g(h())))`.
func (c *RankGroupClient) Use(hooks ...Hook) {
	c.hooks.RankGroup = append(c.hooks.RankGroup, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `rankgroup.Intercept(f(g(h())))`.
func (c *RankGroupClient) Intercept(interceptors ...Interceptor) {
	c.inters.RankGroup = append(c.inters.RankGroup, interceptors...)
}

// Create returns a builder for creating a RankGroup entity.
func (c *RankGroupClient) Create() *RankGroupCreate {
	mutation := newRankGroupMutation(c.config, OpCreate)
	return &RankGroupCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RankGroup entities.
func (c *RankGroupClient) CreateBulk(builders ...*RankGroupCreate) *RankGroupCreateBulk {
	return &RankGroupCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RankGroupClient) MapCreateBulk(slice any, setFunc func(*RankGroupCreate, int)) *RankGroupCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RankGroupCreateBulk{err: fmt.Errorf("calling to RankGroupClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RankGroupCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RankGroupCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RankGroup.
func (c *RankGroupClient) Update() *RankGroupUpdate {
	mutation := newRankGroupMutation(c.config, OpUpdate)
	return &RankGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RankGroupClient) UpdateOne(_m *RankGroup) *RankGroupUpdateOne {
	mutation := newRankGroupMutation(c.config, OpUpdateOne, withRankGroup(_m))
	return &RankGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RankGroupClient) UpdateOneID(id int) *RankGroupUpdateOne {
	mutation := newRankGroupMutation(c.config, OpUpdateOne, withRankGroupID(id))
	return &RankGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RankGroup.
func (c *RankGroupClient) Delete() *RankGroupDelete {
	mutation := newRankGroupMutation(c.config, OpDelete)
	return &RankGroupDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RankGroupClient) DeleteOne(_m *RankGroup) *RankGroupDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RankGroupClient) DeleteOneID(id int) *RankGroupDeleteOne {
	builder := c.Delete().Where(rankgroup.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RankGroupDeleteOne{builder}
}

// Query returns a query builder for RankGroup.
func (c *RankGroupClient) Query() *RankGroupQuery {
	return &RankGroupQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRankGroup},
		inters: c.Interceptors(),
	}
}

// Get returns a RankGroup entity by its id.
func (c *RankGroupClient) Get(ctx context.Context, id int) (*RankGroup, error) {
	return c.Query().Where(rankgroup.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RankGroupClient) GetX(ctx context.Context, id int) *RankGroup {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTournament queries the tournament edge of a RankGroup.
func (c *RankGroupClient) QueryTournament(_m *RankGroup) *TournamentQuery {
	query := (&TournamentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rankgroup.Table, rankgroup.FieldID, id),
			sqlgraph.To(tournament.Table, tournament.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, rankgroup.TournamentTable, rankgroup.TournamentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a RankGroup.
func (c *RankGroupClient) QueryTeams(_m *RankGroup) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(rankgroup.Table, rankgroup.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, rankgroup.TeamsTable, rankgroup.TeamsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RankGroupClient) Hooks() []Hook {
	return c.hooks.RankGroup
}

// Interceptors returns the client interceptors.
func (c *RankGroupClient) Interceptors() []Interceptor {
	return c.inters.RankGroup
}

func (c *RankGroupClient) mutate(ctx context.Context, m *RankGroupMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RankGroupCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RankGroupUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RankGroupUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RankGroupDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RankGroup mutation op: %q", m.Op())
	}
}

// TeamClient is a client for the Team schema.
type TeamClient struct {
	config
}

// NewTeamClient returns a client for the Team from the given config.
func NewTeamClient(c config) *TeamClient {
	return &TeamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `team.Hooks(f(g(h())))`.
func (c *TeamClient) Use(hooks ...Hook) {
	c.hooks.Team = append(c.hooks.Team, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `team.Intercept(f(g(h())))`.
func (c *TeamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Team = append(c.inters.Team, interceptors...)
}

// Create returns a builder for creating a Team entity.
func (c *TeamClient) Create() *TeamCreate {
	mutation := newTeamMutation(c.config, OpCreate)
	return &TeamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Team entities.
func (c *TeamClient) CreateBulk(builders ...*TeamCreate) *TeamCreateBulk {
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamClient) MapCreateBulk(slice any, setFunc func(*TeamCreate, int)) *TeamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamCreateBulk{err: fmt.Errorf("calling to TeamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Team.
func (c *TeamClient) Update() *TeamUpdate {
	mutation := newTeamMutation(c.config, OpUpdate)
	return &TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamClient) UpdateOne(_m *Team) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeam(_m))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamClient) UpdateOneID(id int) *TeamUpdateOne {
	mutation := newTeamMutation(c.config, OpUpdateOne, withTeamID(id))
	return &TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Team.
func (c *TeamClient) Delete() *TeamDelete {
	mutation := newTeamMutation(c.config, OpDelete)
	return &TeamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamClient) DeleteOne(_m *Team) *TeamDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamClient) DeleteOneID(id int) *TeamDeleteOne {
	builder := c.Delete().Where(team.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamDeleteOne{builder}
}

// Query returns a query builder for Team.
func (c *TeamClient) Query() *TeamQuery {
	return &TeamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeam},
		inters: c.Interceptors(),
	}
}

// Get returns a Team entity by its id.
func (c *TeamClient) Get(ctx context.Context, id int) (*Team, error) {
	return c.Query().Where(team.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamClient) GetX(ctx context.Context, id int) *Team {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryTournament queries the tournament edge of a Team.
func (c *TeamClient) QueryTournament(_m *Team) *TournamentQuery {
	query := (&TournamentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(tournament.Table, tournament.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, team.TournamentTable, team.TournamentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a Team.
func (c *TeamClient) QueryCreator(_m *Team) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, team.CreatorTable, team.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMembers queries the members edge of a Team.
func (c *TeamClient) QueryMembers(_m *Team) *TeamMemberQuery {
	query := (&TeamMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(teammember.Table, teammember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.MembersTable, team.MembersColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRankGroup queries the rank_group edge of a Team.
func (c *TeamClient) QueryRankGroup(_m *Team) *RankGroupQuery {
	query := (&RankGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(rankgroup.Table, rankgroup.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, team.RankGroupTable, team.RankGroupColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInvitations queries the invitations edge of a Team.
func (c *TeamClient) QueryInvitations(_m *Team) *InvitationQuery {
	query := (&InvitationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(team.Table, team.FieldID, id),
			sqlgraph.To(invitation.Table, invitation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, team.InvitationsTable, team.InvitationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamClient) Hooks() []Hook {
	return c.hooks.Team
}

// Interceptors returns the client interceptors.
func (c *TeamClient) Interceptors() []Interceptor {
	return c.inters.Team
}

func (c *TeamClient) mutate(ctx context.Context, m *TeamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Team mutation op: %q", m.Op())
	}
}

// TeamMemberClient is a client for the TeamMember schema.
type TeamMemberClient struct {
	config
}

// NewTeamMemberClient returns a client for the TeamMember from the given config.
func NewTeamMemberClient(c config) *TeamMemberClient {
	return &TeamMemberClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `teammember.Hooks(f(g(h())))`.
func (c *TeamMemberClient) Use(hooks ...Hook) {
	c.hooks.TeamMember = append(c.hooks.TeamMember, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `teammember.Intercept(f(g(h())))`.
func (c *TeamMemberClient) Intercept(interceptors ...Interceptor) {
	c.inters.TeamMember = append(c.inters.TeamMember, interceptors...)
}

// Create returns a builder for creating a TeamMember entity.
func (c *TeamMemberClient) Create() *TeamMemberCreate {
	mutation := newTeamMemberMutation(c.config, OpCreate)
	return &TeamMemberCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TeamMember entities.
func (c *TeamMemberClient) CreateBulk(builders ...*TeamMemberCreate) *TeamMemberCreateBulk {
	return &TeamMemberCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TeamMemberClient) MapCreateBulk(slice any, setFunc func(*TeamMemberCreate, int)) *TeamMemberCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TeamMemberCreateBulk{err: fmt.Errorf("calling to TeamMemberClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TeamMemberCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TeamMemberCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TeamMember.
func (c *TeamMemberClient) Update() *TeamMemberUpdate {
	mutation := newTeamMemberMutation(c.config, OpUpdate)
	return &TeamMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TeamMemberClient) UpdateOne(_m *TeamMember) *TeamMemberUpdateOne {
	mutation := newTeamMemberMutation(c.config, OpUpdateOne, withTeamMember(_m))
	return &TeamMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TeamMemberClient) UpdateOneID(id int) *TeamMemberUpdateOne {
	mutation := newTeamMemberMutation(c.config, OpUpdateOne, withTeamMemberID(id))
	return &TeamMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TeamMember.
func (c *TeamMemberClient) Delete() *TeamMemberDelete {
	mutation := newTeamMemberMutation(c.config, OpDelete)
	return &TeamMemberDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TeamMemberClient) DeleteOne(_m *TeamMember) *TeamMemberDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TeamMemberClient) DeleteOneID(id int) *TeamMemberDeleteOne {
	builder := c.Delete().Where(teammember.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TeamMemberDeleteOne{builder}
}

// Query returns a query builder for TeamMember.
func (c *TeamMemberClient) Query() *TeamMemberQuery {
	return &TeamMemberQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTeamMember},
		inters: c.Interceptors(),
	}
}

// Get returns a TeamMember entity by its id.
func (c *TeamMemberClient) Get(ctx context.Context, id int) (*TeamMember, error) {
	return c.Query().Where(teammember.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TeamMemberClient) GetX(ctx context.Context, id int) *TeamMember {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a TeamMember.
func (c *TeamMemberClient) QueryUser(_m *TeamMember) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(teammember.Table, teammember.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, teammember.UserTable, teammember.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeam queries the team edge of a TeamMember.
func (c *TeamMemberClient) QueryTeam(_m *TeamMember) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(teammember.Table, teammember.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, teammember.TeamTable, teammember.TeamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TeamMemberClient) Hooks() []Hook {
	return c.hooks.TeamMember
}

// Interceptors returns the client interceptors.
func (c *TeamMemberClient) Interceptors() []Interceptor {
	return c.inters.TeamMember
}

func (c *TeamMemberClient) mutate(ctx context.Context, m *TeamMemberMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TeamMemberCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TeamMemberUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TeamMemberUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TeamMemberDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TeamMember mutation op: %q", m.Op())
	}
}

// TournamentClient is a client for the Tournament schema.
type TournamentClient struct {
	config
}

// NewTournamentClient returns a client for the Tournament from the given config.
func NewTournamentClient(c config) *TournamentClient {
	return &TournamentClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tournament.Hooks(f(g(h())))`.
func (c *TournamentClient) Use(hooks ...Hook) {
	c.hooks.Tournament = append(c.hooks.Tournament, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tournament.Intercept(f(g(h())))`.
func (c *TournamentClient) Intercept(interceptors ...Interceptor) {
	c.inters.Tournament = append(c.inters.Tournament, interceptors...)
}

// Create returns a builder for creating a Tournament entity.
func (c *TournamentClient) Create() *TournamentCreate {
	mutation := newTournamentMutation(c.config, OpCreate)
	return &TournamentCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Tournament entities.
func (c *TournamentClient) CreateBulk(builders ...*TournamentCreate) *TournamentCreateBulk {
	return &TournamentCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TournamentClient) MapCreateBulk(slice any, setFunc func(*TournamentCreate, int)) *TournamentCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TournamentCreateBulk{err: fmt.Errorf("calling to TournamentClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TournamentCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TournamentCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Tournament.
func (c *TournamentClient) Update() *TournamentUpdate {
	mutation := newTournamentMutation(c.config, OpUpdate)
	return &TournamentUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TournamentClient) UpdateOne(_m *Tournament) *TournamentUpdateOne {
	mutation := newTournamentMutation(c.config, OpUpdateOne, withTournament(_m))
	return &TournamentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TournamentClient) UpdateOneID(id int) *TournamentUpdateOne {
	mutation := newTournamentMutation(c.config, OpUpdateOne, withTournamentID(id))
	return &TournamentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Tournament.
func (c *TournamentClient) Delete() *TournamentDelete {
	mutation := newTournamentMutation(c.config, OpDelete)
	return &TournamentDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TournamentClient) DeleteOne(_m *Tournament) *TournamentDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TournamentClient) DeleteOneID(id int) *TournamentDeleteOne {
	builder := c.Delete().Where(tournament.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TournamentDeleteOne{builder}
}

// Query returns a query builder for Tournament.
func (c *TournamentClient) Query() *TournamentQuery {
	return &TournamentQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTournament},
		inters: c.Interceptors(),
	}
}

// Get returns a Tournament entity by its id.
func (c *TournamentClient) Get(ctx context.Context, id int) (*Tournament, error) {
	return c.Query().Where(tournament.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TournamentClient) GetX(ctx context.Context, id int) *Tournament {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryCreator queries the creator edge of a Tournament.
func (c *TournamentClient) QueryCreator(_m *Tournament) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tournament.Table, tournament.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tournament.CreatorTable, tournament.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAdmins queries the admins edge of a Tournament.
func (c *TournamentClient) QueryAdmins(_m *Tournament) *TournamentAdminQuery {
	query := (&TournamentAdminClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tournament.Table, tournament.FieldID, id),
			sqlgraph.To(tournamentadmin.Table, tournamentadmin.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tournament.AdminsTable, tournament.AdminsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeams queries the teams edge of a Tournament.
func (c *TournamentClient) QueryTeams(_m *Tournament) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tournament.Table, tournament.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tournament.TeamsTable, tournament.TeamsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRankGroups queries the rank_groups edge of a Tournament.
func (c *TournamentClient) QueryRankGroups(_m *Tournament) *RankGroupQuery {
	query := (&RankGroupClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tournament.Table, tournament.FieldID, id),
			sqlgraph.To(rankgroup.Table, rankgroup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, tournament.RankGroupsTable, tournament.RankGroupsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TournamentClient) Hooks() []Hook {
	return c.hooks.Tournament
}

// Interceptors returns the client interceptors.
func (c *TournamentClient) Interceptors() []Interceptor {
	return c.inters.Tournament
}

func (c *TournamentClient) mutate(ctx context.Context, m *TournamentMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TournamentCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TournamentUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TournamentUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TournamentDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Tournament mutation op: %q", m.Op())
	}
}

// TournamentAdminClient is a client for the TournamentAdmin schema.
type TournamentAdminClient struct {
	config
}

// NewTournamentAdminClient returns a client for the TournamentAdmin from the given config.
func NewTournamentAdminClient(c config) *TournamentAdminClient {
	return &TournamentAdminClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `tournamentadmin.Hooks(f(g(h())))`.
func (c *TournamentAdminClient) Use(hooks ...Hook) {
	c.hooks.TournamentAdmin = append(c.hooks.TournamentAdmin, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `tournamentadmin.Intercept(f(g(h())))`.
func (c *TournamentAdminClient) Intercept(interceptors ...Interceptor) {
	c.inters.TournamentAdmin = append(c.inters.TournamentAdmin, interceptors...)
}

// Create returns a builder for creating a TournamentAdmin entity.
func (c *TournamentAdminClient) Create() *TournamentAdminCreate {
	mutation := newTournamentAdminMutation(c.config, OpCreate)
	return &TournamentAdminCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of TournamentAdmin entities.
func (c *TournamentAdminClient) CreateBulk(builders ...*TournamentAdminCreate) *TournamentAdminCreateBulk {
	return &TournamentAdminCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TournamentAdminClient) MapCreateBulk(slice any, setFunc func(*TournamentAdminCreate, int)) *TournamentAdminCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TournamentAdminCreateBulk{err: fmt.Errorf("calling to TournamentAdminClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TournamentAdminCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TournamentAdminCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for TournamentAdmin.
func (c *TournamentAdminClient) Update() *TournamentAdminUpdate {
	mutation := newTournamentAdminMutation(c.config, OpUpdate)
	return &TournamentAdminUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TournamentAdminClient) UpdateOne(_m *TournamentAdmin) *TournamentAdminUpdateOne {
	mutation := newTournamentAdminMutation(c.config, OpUpdateOne, withTournamentAdmin(_m))
	return &TournamentAdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TournamentAdminClient) UpdateOneID(id int) *TournamentAdminUpdateOne {
	mutation := newTournamentAdminMutation(c.config, OpUpdateOne, withTournamentAdminID(id))
	return &TournamentAdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for TournamentAdmin.
func (c *TournamentAdminClient) Delete() *TournamentAdminDelete {
	mutation := newTournamentAdminMutation(c.config, OpDelete)
	return &TournamentAdminDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TournamentAdminClient) DeleteOne(_m *TournamentAdmin) *TournamentAdminDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TournamentAdminClient) DeleteOneID(id int) *TournamentAdminDeleteOne {
	builder := c.Delete().Where(tournamentadmin.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TournamentAdminDeleteOne{builder}
}

// Query returns a query builder for TournamentAdmin.
func (c *TournamentAdminClient) Query() *TournamentAdminQuery {
	return &TournamentAdminQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTournamentAdmin},
		inters: c.Interceptors(),
	}
}

// Get returns a TournamentAdmin entity by its id.
func (c *TournamentAdminClient) Get(ctx context.Context, id int) (*TournamentAdmin, error) {
	return c.Query().Where(tournamentadmin.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TournamentAdminClient) GetX(ctx context.Context, id int) *TournamentAdmin {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a TournamentAdmin.
func (c *TournamentAdminClient) QueryUser(_m *TournamentAdmin) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tournamentadmin.Table, tournamentadmin.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tournamentadmin.UserTable, tournamentadmin.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTournament queries the tournament edge of a TournamentAdmin.
func (c *TournamentAdminClient) QueryTournament(_m *TournamentAdmin) *TournamentQuery {
	query := (&TournamentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(tournamentadmin.Table, tournamentadmin.FieldID, id),
			sqlgraph.To(tournament.Table, tournament.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, tournamentadmin.TournamentTable, tournamentadmin.TournamentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TournamentAdminClient) Hooks() []Hook {
	return c.hooks.TournamentAdmin
}

// Interceptors returns the client interceptors.
func (c *TournamentAdminClient) Interceptors() []Interceptor {
	return c.inters.TournamentAdmin
}

func (c *TournamentAdminClient) mutate(ctx context.Context, m *TournamentAdminMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TournamentAdminCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TournamentAdminUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TournamentAdminUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TournamentAdminDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown TournamentAdmin mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(_m *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(_m))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id int) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(_m *User) *UserDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id int) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id int) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id int) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUserVotes queries the user_votes edge of a User.
func (c *UserClient) QueryUserVotes(_m *User) *UserVoteQuery {
	query := (&UserVoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(uservote.Table, uservote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.UserVotesTable, user.UserVotesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedVotes queries the created_votes edge of a User.
func (c *UserClient) QueryCreatedVotes(_m *User) *VoteQuery {
	query := (&VoteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(vote.Table, vote.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedVotesTable, user.CreatedVotesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryApps queries the apps edge of a User.
func (c *UserClient) QueryApps(_m *User) *AppQuery {
	query := (&AppClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(app.Table, app.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.AppsTable, user.AppsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryConsents queries the consents edge of a User.
func (c *UserClient) QueryConsents(_m *User) *ConsentQuery {
	query := (&ConsentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(consent.Table, consent.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ConsentsTable, user.ConsentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTeamMemberships queries the team_memberships edge of a User.
func (c *UserClient) QueryTeamMemberships(_m *User) *TeamMemberQuery {
	query := (&TeamMemberClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(teammember.Table, teammember.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TeamMembershipsTable, user.TeamMembershipsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryReceivedInvitations queries the received_invitations edge of a User.
func (c *UserClient) QueryReceivedInvitations(_m *User) *InvitationQuery {
	query := (&InvitationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(invitation.Table, invitation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.ReceivedInvitationsTable, user.ReceivedInvitationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedTeams queries the created_teams edge of a User.
func (c *UserClient) QueryCreatedTeams(_m *User) *TeamQuery {
	query := (&TeamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(team.Table, team.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedTeamsTable, user.CreatedTeamsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreatedTournaments queries the created_tournaments edge of a User.
func (c *UserClient) QueryCreatedTournaments(_m *User) *TournamentQuery {
	query := (&TournamentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tournament.Table, tournament.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.CreatedTournamentsTable, user.CreatedTournamentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTournamentAdminRoles queries the tournament_admin_roles edge of a User.
func (c *UserClient) QueryTournamentAdminRoles(_m *User) *TournamentAdminQuery {
	query := (&TournamentAdminClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(tournamentadmin.Table, tournamentadmin.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.TournamentAdminRolesTable, user.TournamentAdminRolesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// UserVoteClient is a client for the UserVote schema.
type UserVoteClient struct {
	config
}

// NewUserVoteClient returns a client for the UserVote from the given config.
func NewUserVoteClient(c config) *UserVoteClient {
	return &UserVoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `uservote.Hooks(f(g(h())))`.
func (c *UserVoteClient) Use(hooks ...Hook) {
	c.hooks.UserVote = append(c.hooks.UserVote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `uservote.Intercept(f(g(h())))`.
func (c *UserVoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.UserVote = append(c.inters.UserVote, interceptors...)
}

// Create returns a builder for creating a UserVote entity.
func (c *UserVoteClient) Create() *UserVoteCreate {
	mutation := newUserVoteMutation(c.config, OpCreate)
	return &UserVoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UserVote entities.
func (c *UserVoteClient) CreateBulk(builders ...*UserVoteCreate) *UserVoteCreateBulk {
	return &UserVoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserVoteClient) MapCreateBulk(slice any, setFunc func(*UserVoteCreate, int)) *UserVoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserVoteCreateBulk{err: fmt.Errorf("calling to UserVoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserVoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserVoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UserVote.
func (c *UserVoteClient) Update() *UserVoteUpdate {
	mutation := newUserVoteMutation(c.config, OpUpdate)
	return &UserVoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserVoteClient) UpdateOne(_m *UserVote) *UserVoteUpdateOne {
	mutation := newUserVoteMutation(c.config, OpUpdateOne, withUserVote(_m))
	return &UserVoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserVoteClient) UpdateOneID(id int) *UserVoteUpdateOne {
	mutation := newUserVoteMutation(c.config, OpUpdateOne, withUserVoteID(id))
	return &UserVoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UserVote.
func (c *UserVoteClient) Delete() *UserVoteDelete {
	mutation := newUserVoteMutation(c.config, OpDelete)
	return &UserVoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserVoteClient) DeleteOne(_m *UserVote) *UserVoteDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserVoteClient) DeleteOneID(id int) *UserVoteDeleteOne {
	builder := c.Delete().Where(uservote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserVoteDeleteOne{builder}
}

// Query returns a query builder for UserVote.
func (c *UserVoteClient) Query() *UserVoteQuery {
	return &UserVoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUserVote},
		inters: c.Interceptors(),
	}
}

// Get returns a UserVote entity by its id.
func (c *UserVoteClient) Get(ctx context.Context, id int) (*UserVote, error) {
	return c.Query().Where(uservote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserVoteClient) GetX(ctx context.Context, id int) *UserVote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a UserVote.
func (c *UserVoteClient) QueryUser(_m *UserVote) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(uservote.Table, uservote.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, uservote.UserTable, uservote.UserColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryComponent queries the component edge of a UserVote.
func (c *UserVoteClient) QueryComponent(_m *UserVote) *ComponentQuery {
	query := (&ComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(uservote.Table, uservote.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, uservote.ComponentTable, uservote.ComponentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserVoteClient) Hooks() []Hook {
	return c.hooks.UserVote
}

// Interceptors returns the client interceptors.
func (c *UserVoteClient) Interceptors() []Interceptor {
	return c.inters.UserVote
}

func (c *UserVoteClient) mutate(ctx context.Context, m *UserVoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserVoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserVoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserVoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserVoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UserVote mutation op: %q", m.Op())
	}
}

// VoteClient is a client for the Vote schema.
type VoteClient struct {
	config
}

// NewVoteClient returns a client for the Vote from the given config.
func NewVoteClient(c config) *VoteClient {
	return &VoteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vote.Hooks(f(g(h())))`.
func (c *VoteClient) Use(hooks ...Hook) {
	c.hooks.Vote = append(c.hooks.Vote, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vote.Intercept(f(g(h())))`.
func (c *VoteClient) Intercept(interceptors ...Interceptor) {
	c.inters.Vote = append(c.inters.Vote, interceptors...)
}

// Create returns a builder for creating a Vote entity.
func (c *VoteClient) Create() *VoteCreate {
	mutation := newVoteMutation(c.config, OpCreate)
	return &VoteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Vote entities.
func (c *VoteClient) CreateBulk(builders ...*VoteCreate) *VoteCreateBulk {
	return &VoteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VoteClient) MapCreateBulk(slice any, setFunc func(*VoteCreate, int)) *VoteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VoteCreateBulk{err: fmt.Errorf("calling to VoteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VoteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VoteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Vote.
func (c *VoteClient) Update() *VoteUpdate {
	mutation := newVoteMutation(c.config, OpUpdate)
	return &VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VoteClient) UpdateOne(_m *Vote) *VoteUpdateOne {
	mutation := newVoteMutation(c.config, OpUpdateOne, withVote(_m))
	return &VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VoteClient) UpdateOneID(id int) *VoteUpdateOne {
	mutation := newVoteMutation(c.config, OpUpdateOne, withVoteID(id))
	return &VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Vote.
func (c *VoteClient) Delete() *VoteDelete {
	mutation := newVoteMutation(c.config, OpDelete)
	return &VoteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VoteClient) DeleteOne(_m *Vote) *VoteDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VoteClient) DeleteOneID(id int) *VoteDeleteOne {
	builder := c.Delete().Where(vote.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VoteDeleteOne{builder}
}

// Query returns a query builder for Vote.
func (c *VoteClient) Query() *VoteQuery {
	return &VoteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVote},
		inters: c.Interceptors(),
	}
}

// Get returns a Vote entity by its id.
func (c *VoteClient) Get(ctx context.Context, id int) (*Vote, error) {
	return c.Query().Where(vote.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VoteClient) GetX(ctx context.Context, id int) *Vote {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryComponents queries the components edge of a Vote.
func (c *VoteClient) QueryComponents(_m *Vote) *ComponentQuery {
	query := (&ComponentClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vote.Table, vote.FieldID, id),
			sqlgraph.To(component.Table, component.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vote.ComponentsTable, vote.ComponentsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCreator queries the creator edge of a Vote.
func (c *VoteClient) QueryCreator(_m *Vote) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vote.Table, vote.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, vote.CreatorTable, vote.CreatorColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VoteClient) Hooks() []Hook {
	return c.hooks.Vote
}

// Interceptors returns the client interceptors.
func (c *VoteClient) Interceptors() []Interceptor {
	return c.inters.Vote
}

func (c *VoteClient) mutate(ctx context.Context, m *VoteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VoteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VoteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VoteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VoteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Vote mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		App, AuthCode, AuthRefreshToken, AuthToken, Component, Consent, Invitation,
		RankGroup, Team, TeamMember, Tournament, TournamentAdmin, User, UserVote,
		Vote []ent.Hook
	}
	inters struct {
		App, AuthCode, AuthRefreshToken, AuthToken, Component, Consent, Invitation,
		RankGroup, Team, TeamMember, Tournament, TournamentAdmin, User, UserVote,
		Vote []ent.Interceptor
	}
)
