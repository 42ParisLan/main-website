// Code generated by ent, DO NOT EDIT.

package ent

import (
	"base-website/ent/app"
	"base-website/ent/authcode"
	"base-website/ent/authrefreshtoken"
	"base-website/ent/authtoken"
	"base-website/ent/component"
	"base-website/ent/consent"
	"base-website/ent/predicate"
	"base-website/ent/user"
	"base-website/ent/uservote"
	"base-website/ent/vote"
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeApp              = "App"
	TypeAuthCode         = "AuthCode"
	TypeAuthRefreshToken = "AuthRefreshToken"
	TypeAuthToken        = "AuthToken"
	TypeComponent        = "Component"
	TypeConsent          = "Consent"
	TypeUser             = "User"
	TypeUserVote         = "UserVote"
	TypeVote             = "Vote"
)

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                  Op
	typ                 string
	id                  *string
	secret              *string
	name                *string
	redirect_uris       *[]string
	appendredirect_uris []string
	implicit_consent    *bool
	description         *string
	created_at          *time.Time
	updated_at          *time.Time
	last_login_at       *time.Time
	roles               *[]string
	appendroles         []string
	clearedFields       map[string]struct{}
	owner               *int
	clearedowner        bool
	consents            map[int]struct{}
	removedconsents     map[int]struct{}
	clearedconsents     bool
	done                bool
	oldValue            func(context.Context) (*App, error)
	predicates          []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id string) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSecret sets the "secret" field.
func (m *AppMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *AppMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ResetSecret resets all changes to the "secret" field.
func (m *AppMutation) ResetSecret() {
	m.secret = nil
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
}

// SetRedirectUris sets the "redirect_uris" field.
func (m *AppMutation) SetRedirectUris(s []string) {
	m.redirect_uris = &s
	m.appendredirect_uris = nil
}

// RedirectUris returns the value of the "redirect_uris" field in the mutation.
func (m *AppMutation) RedirectUris() (r []string, exists bool) {
	v := m.redirect_uris
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectUris returns the old "redirect_uris" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRedirectUris(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectUris is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectUris requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectUris: %w", err)
	}
	return oldValue.RedirectUris, nil
}

// AppendRedirectUris adds s to the "redirect_uris" field.
func (m *AppMutation) AppendRedirectUris(s []string) {
	m.appendredirect_uris = append(m.appendredirect_uris, s...)
}

// AppendedRedirectUris returns the list of values that were appended to the "redirect_uris" field in this mutation.
func (m *AppMutation) AppendedRedirectUris() ([]string, bool) {
	if len(m.appendredirect_uris) == 0 {
		return nil, false
	}
	return m.appendredirect_uris, true
}

// ResetRedirectUris resets all changes to the "redirect_uris" field.
func (m *AppMutation) ResetRedirectUris() {
	m.redirect_uris = nil
	m.appendredirect_uris = nil
}

// SetImplicitConsent sets the "implicit_consent" field.
func (m *AppMutation) SetImplicitConsent(b bool) {
	m.implicit_consent = &b
}

// ImplicitConsent returns the value of the "implicit_consent" field in the mutation.
func (m *AppMutation) ImplicitConsent() (r bool, exists bool) {
	v := m.implicit_consent
	if v == nil {
		return
	}
	return *v, true
}

// OldImplicitConsent returns the old "implicit_consent" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldImplicitConsent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplicitConsent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplicitConsent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplicitConsent: %w", err)
	}
	return oldValue.ImplicitConsent, nil
}

// ResetImplicitConsent resets all changes to the "implicit_consent" field.
func (m *AppMutation) ResetImplicitConsent() {
	m.implicit_consent = nil
}

// SetDescription sets the "description" field.
func (m *AppMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AppMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AppMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetLastLoginAt sets the "last_login_at" field.
func (m *AppMutation) SetLastLoginAt(t time.Time) {
	m.last_login_at = &t
}

// LastLoginAt returns the value of the "last_login_at" field in the mutation.
func (m *AppMutation) LastLoginAt() (r time.Time, exists bool) {
	v := m.last_login_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAt returns the old "last_login_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLastLoginAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAt: %w", err)
	}
	return oldValue.LastLoginAt, nil
}

// ClearLastLoginAt clears the value of the "last_login_at" field.
func (m *AppMutation) ClearLastLoginAt() {
	m.last_login_at = nil
	m.clearedFields[app.FieldLastLoginAt] = struct{}{}
}

// LastLoginAtCleared returns if the "last_login_at" field was cleared in this mutation.
func (m *AppMutation) LastLoginAtCleared() bool {
	_, ok := m.clearedFields[app.FieldLastLoginAt]
	return ok
}

// ResetLastLoginAt resets all changes to the "last_login_at" field.
func (m *AppMutation) ResetLastLoginAt() {
	m.last_login_at = nil
	delete(m.clearedFields, app.FieldLastLoginAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *AppMutation) SetOwnerID(i int) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *AppMutation) OwnerID() (r int, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldOwnerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *AppMutation) ResetOwnerID() {
	m.owner = nil
}

// SetRoles sets the "roles" field.
func (m *AppMutation) SetRoles(s []string) {
	m.roles = &s
	m.appendroles = nil
}

// Roles returns the value of the "roles" field in the mutation.
func (m *AppMutation) Roles() (r []string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoles returns the old "roles" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoles: %w", err)
	}
	return oldValue.Roles, nil
}

// AppendRoles adds s to the "roles" field.
func (m *AppMutation) AppendRoles(s []string) {
	m.appendroles = append(m.appendroles, s...)
}

// AppendedRoles returns the list of values that were appended to the "roles" field in this mutation.
func (m *AppMutation) AppendedRoles() ([]string, bool) {
	if len(m.appendroles) == 0 {
		return nil, false
	}
	return m.appendroles, true
}

// ResetRoles resets all changes to the "roles" field.
func (m *AppMutation) ResetRoles() {
	m.roles = nil
	m.appendroles = nil
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AppMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[app.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AppMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AppMutation) OwnerIDs() (ids []int) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AppMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// AddConsentIDs adds the "consents" edge to the Consent entity by ids.
func (m *AppMutation) AddConsentIDs(ids ...int) {
	if m.consents == nil {
		m.consents = make(map[int]struct{})
	}
	for i := range ids {
		m.consents[ids[i]] = struct{}{}
	}
}

// ClearConsents clears the "consents" edge to the Consent entity.
func (m *AppMutation) ClearConsents() {
	m.clearedconsents = true
}

// ConsentsCleared reports if the "consents" edge to the Consent entity was cleared.
func (m *AppMutation) ConsentsCleared() bool {
	return m.clearedconsents
}

// RemoveConsentIDs removes the "consents" edge to the Consent entity by IDs.
func (m *AppMutation) RemoveConsentIDs(ids ...int) {
	if m.removedconsents == nil {
		m.removedconsents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.consents, ids[i])
		m.removedconsents[ids[i]] = struct{}{}
	}
}

// RemovedConsents returns the removed IDs of the "consents" edge to the Consent entity.
func (m *AppMutation) RemovedConsentsIDs() (ids []int) {
	for id := range m.removedconsents {
		ids = append(ids, id)
	}
	return
}

// ConsentsIDs returns the "consents" edge IDs in the mutation.
func (m *AppMutation) ConsentsIDs() (ids []int) {
	for id := range m.consents {
		ids = append(ids, id)
	}
	return
}

// ResetConsents resets all changes to the "consents" edge.
func (m *AppMutation) ResetConsents() {
	m.consents = nil
	m.clearedconsents = false
	m.removedconsents = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.secret != nil {
		fields = append(fields, app.FieldSecret)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.redirect_uris != nil {
		fields = append(fields, app.FieldRedirectUris)
	}
	if m.implicit_consent != nil {
		fields = append(fields, app.FieldImplicitConsent)
	}
	if m.description != nil {
		fields = append(fields, app.FieldDescription)
	}
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.last_login_at != nil {
		fields = append(fields, app.FieldLastLoginAt)
	}
	if m.owner != nil {
		fields = append(fields, app.FieldOwnerID)
	}
	if m.roles != nil {
		fields = append(fields, app.FieldRoles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldSecret:
		return m.Secret()
	case app.FieldName:
		return m.Name()
	case app.FieldRedirectUris:
		return m.RedirectUris()
	case app.FieldImplicitConsent:
		return m.ImplicitConsent()
	case app.FieldDescription:
		return m.Description()
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldLastLoginAt:
		return m.LastLoginAt()
	case app.FieldOwnerID:
		return m.OwnerID()
	case app.FieldRoles:
		return m.Roles()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldSecret:
		return m.OldSecret(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldRedirectUris:
		return m.OldRedirectUris(ctx)
	case app.FieldImplicitConsent:
		return m.OldImplicitConsent(ctx)
	case app.FieldDescription:
		return m.OldDescription(ctx)
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldLastLoginAt:
		return m.OldLastLoginAt(ctx)
	case app.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case app.FieldRoles:
		return m.OldRoles(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldRedirectUris:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectUris(v)
		return nil
	case app.FieldImplicitConsent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplicitConsent(v)
		return nil
	case app.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldLastLoginAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAt(v)
		return nil
	case app.FieldOwnerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case app.FieldRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoles(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldLastLoginAt) {
		fields = append(fields, app.FieldLastLoginAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldLastLoginAt:
		m.ClearLastLoginAt()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldSecret:
		m.ResetSecret()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldRedirectUris:
		m.ResetRedirectUris()
		return nil
	case app.FieldImplicitConsent:
		m.ResetImplicitConsent()
		return nil
	case app.FieldDescription:
		m.ResetDescription()
		return nil
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldLastLoginAt:
		m.ResetLastLoginAt()
		return nil
	case app.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case app.FieldRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.owner != nil {
		edges = append(edges, app.EdgeOwner)
	}
	if m.consents != nil {
		edges = append(edges, app.EdgeConsents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeConsents:
		ids := make([]ent.Value, 0, len(m.consents))
		for id := range m.consents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedconsents != nil {
		edges = append(edges, app.EdgeConsents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeConsents:
		ids := make([]ent.Value, 0, len(m.removedconsents))
		for id := range m.removedconsents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedowner {
		edges = append(edges, app.EdgeOwner)
	}
	if m.clearedconsents {
		edges = append(edges, app.EdgeConsents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeOwner:
		return m.clearedowner
	case app.EdgeConsents:
		return m.clearedconsents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	case app.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeOwner:
		m.ResetOwner()
		return nil
	case app.EdgeConsents:
		m.ResetConsents()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AuthCodeMutation represents an operation that mutates the AuthCode nodes in the graph.
type AuthCodeMutation struct {
	config
	op              Op
	typ             string
	id              *string
	auth_request_id *string
	expiration      *time.Time
	clearedFields   map[string]struct{}
	done            bool
	oldValue        func(context.Context) (*AuthCode, error)
	predicates      []predicate.AuthCode
}

var _ ent.Mutation = (*AuthCodeMutation)(nil)

// authcodeOption allows management of the mutation configuration using functional options.
type authcodeOption func(*AuthCodeMutation)

// newAuthCodeMutation creates new mutation for the AuthCode entity.
func newAuthCodeMutation(c config, op Op, opts ...authcodeOption) *AuthCodeMutation {
	m := &AuthCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthCodeID sets the ID field of the mutation.
func withAuthCodeID(id string) authcodeOption {
	return func(m *AuthCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthCode
		)
		m.oldValue = func(ctx context.Context) (*AuthCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthCode sets the old AuthCode of the mutation.
func withAuthCode(node *AuthCode) authcodeOption {
	return func(m *AuthCodeMutation) {
		m.oldValue = func(context.Context) (*AuthCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthCode entities.
func (m *AuthCodeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthCodeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthCodeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAuthRequestID sets the "auth_request_id" field.
func (m *AuthCodeMutation) SetAuthRequestID(s string) {
	m.auth_request_id = &s
}

// AuthRequestID returns the value of the "auth_request_id" field in the mutation.
func (m *AuthCodeMutation) AuthRequestID() (r string, exists bool) {
	v := m.auth_request_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthRequestID returns the old "auth_request_id" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldAuthRequestID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthRequestID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthRequestID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthRequestID: %w", err)
	}
	return oldValue.AuthRequestID, nil
}

// ResetAuthRequestID resets all changes to the "auth_request_id" field.
func (m *AuthCodeMutation) ResetAuthRequestID() {
	m.auth_request_id = nil
}

// SetExpiration sets the "expiration" field.
func (m *AuthCodeMutation) SetExpiration(t time.Time) {
	m.expiration = &t
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *AuthCodeMutation) Expiration() (r time.Time, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the AuthCode entity.
// If the AuthCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthCodeMutation) OldExpiration(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *AuthCodeMutation) ResetExpiration() {
	m.expiration = nil
}

// Where appends a list predicates to the AuthCodeMutation builder.
func (m *AuthCodeMutation) Where(ps ...predicate.AuthCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthCode).
func (m *AuthCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthCodeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.auth_request_id != nil {
		fields = append(fields, authcode.FieldAuthRequestID)
	}
	if m.expiration != nil {
		fields = append(fields, authcode.FieldExpiration)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authcode.FieldAuthRequestID:
		return m.AuthRequestID()
	case authcode.FieldExpiration:
		return m.Expiration()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authcode.FieldAuthRequestID:
		return m.OldAuthRequestID(ctx)
	case authcode.FieldExpiration:
		return m.OldExpiration(ctx)
	}
	return nil, fmt.Errorf("unknown AuthCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authcode.FieldAuthRequestID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthRequestID(v)
		return nil
	case authcode.FieldExpiration:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	}
	return fmt.Errorf("unknown AuthCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthCodeMutation) ResetField(name string) error {
	switch name {
	case authcode.FieldAuthRequestID:
		m.ResetAuthRequestID()
		return nil
	case authcode.FieldExpiration:
		m.ResetExpiration()
		return nil
	}
	return fmt.Errorf("unknown AuthCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthCodeMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthCodeMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthCodeMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthCodeMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthCode edge %s", name)
}

// AuthRefreshTokenMutation represents an operation that mutates the AuthRefreshToken nodes in the graph.
type AuthRefreshTokenMutation struct {
	config
	op             Op
	typ            string
	id             *string
	_Token         *string
	subject        *string
	auth_time      *time.Time
	amr            *[]string
	appendamr      []string
	audience       *[]string
	appendaudience []string
	user_id        *string
	application_id *string
	expiration     *time.Time
	scopes         *[]string
	appendscopes   []string
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*AuthRefreshToken, error)
	predicates     []predicate.AuthRefreshToken
}

var _ ent.Mutation = (*AuthRefreshTokenMutation)(nil)

// authrefreshtokenOption allows management of the mutation configuration using functional options.
type authrefreshtokenOption func(*AuthRefreshTokenMutation)

// newAuthRefreshTokenMutation creates new mutation for the AuthRefreshToken entity.
func newAuthRefreshTokenMutation(c config, op Op, opts ...authrefreshtokenOption) *AuthRefreshTokenMutation {
	m := &AuthRefreshTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthRefreshToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthRefreshTokenID sets the ID field of the mutation.
func withAuthRefreshTokenID(id string) authrefreshtokenOption {
	return func(m *AuthRefreshTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthRefreshToken
		)
		m.oldValue = func(ctx context.Context) (*AuthRefreshToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthRefreshToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthRefreshToken sets the old AuthRefreshToken of the mutation.
func withAuthRefreshToken(node *AuthRefreshToken) authrefreshtokenOption {
	return func(m *AuthRefreshTokenMutation) {
		m.oldValue = func(context.Context) (*AuthRefreshToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthRefreshTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthRefreshTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthRefreshToken entities.
func (m *AuthRefreshTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthRefreshTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthRefreshTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthRefreshToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetToken sets the "Token" field.
func (m *AuthRefreshTokenMutation) SetToken(s string) {
	m._Token = &s
}

// Token returns the value of the "Token" field in the mutation.
func (m *AuthRefreshTokenMutation) Token() (r string, exists bool) {
	v := m._Token
	if v == nil {
		return
	}
	return *v, true
}

// OldToken returns the old "Token" field's value of the AuthRefreshToken entity.
// If the AuthRefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRefreshTokenMutation) OldToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToken: %w", err)
	}
	return oldValue.Token, nil
}

// ResetToken resets all changes to the "Token" field.
func (m *AuthRefreshTokenMutation) ResetToken() {
	m._Token = nil
}

// SetSubject sets the "subject" field.
func (m *AuthRefreshTokenMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *AuthRefreshTokenMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the AuthRefreshToken entity.
// If the AuthRefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRefreshTokenMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *AuthRefreshTokenMutation) ResetSubject() {
	m.subject = nil
}

// SetAuthTime sets the "auth_time" field.
func (m *AuthRefreshTokenMutation) SetAuthTime(t time.Time) {
	m.auth_time = &t
}

// AuthTime returns the value of the "auth_time" field in the mutation.
func (m *AuthRefreshTokenMutation) AuthTime() (r time.Time, exists bool) {
	v := m.auth_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthTime returns the old "auth_time" field's value of the AuthRefreshToken entity.
// If the AuthRefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRefreshTokenMutation) OldAuthTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthTime: %w", err)
	}
	return oldValue.AuthTime, nil
}

// ResetAuthTime resets all changes to the "auth_time" field.
func (m *AuthRefreshTokenMutation) ResetAuthTime() {
	m.auth_time = nil
}

// SetAmr sets the "amr" field.
func (m *AuthRefreshTokenMutation) SetAmr(s []string) {
	m.amr = &s
	m.appendamr = nil
}

// Amr returns the value of the "amr" field in the mutation.
func (m *AuthRefreshTokenMutation) Amr() (r []string, exists bool) {
	v := m.amr
	if v == nil {
		return
	}
	return *v, true
}

// OldAmr returns the old "amr" field's value of the AuthRefreshToken entity.
// If the AuthRefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRefreshTokenMutation) OldAmr(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAmr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAmr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAmr: %w", err)
	}
	return oldValue.Amr, nil
}

// AppendAmr adds s to the "amr" field.
func (m *AuthRefreshTokenMutation) AppendAmr(s []string) {
	m.appendamr = append(m.appendamr, s...)
}

// AppendedAmr returns the list of values that were appended to the "amr" field in this mutation.
func (m *AuthRefreshTokenMutation) AppendedAmr() ([]string, bool) {
	if len(m.appendamr) == 0 {
		return nil, false
	}
	return m.appendamr, true
}

// ResetAmr resets all changes to the "amr" field.
func (m *AuthRefreshTokenMutation) ResetAmr() {
	m.amr = nil
	m.appendamr = nil
}

// SetAudience sets the "audience" field.
func (m *AuthRefreshTokenMutation) SetAudience(s []string) {
	m.audience = &s
	m.appendaudience = nil
}

// Audience returns the value of the "audience" field in the mutation.
func (m *AuthRefreshTokenMutation) Audience() (r []string, exists bool) {
	v := m.audience
	if v == nil {
		return
	}
	return *v, true
}

// OldAudience returns the old "audience" field's value of the AuthRefreshToken entity.
// If the AuthRefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRefreshTokenMutation) OldAudience(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudience: %w", err)
	}
	return oldValue.Audience, nil
}

// AppendAudience adds s to the "audience" field.
func (m *AuthRefreshTokenMutation) AppendAudience(s []string) {
	m.appendaudience = append(m.appendaudience, s...)
}

// AppendedAudience returns the list of values that were appended to the "audience" field in this mutation.
func (m *AuthRefreshTokenMutation) AppendedAudience() ([]string, bool) {
	if len(m.appendaudience) == 0 {
		return nil, false
	}
	return m.appendaudience, true
}

// ResetAudience resets all changes to the "audience" field.
func (m *AuthRefreshTokenMutation) ResetAudience() {
	m.audience = nil
	m.appendaudience = nil
}

// SetUserID sets the "user_id" field.
func (m *AuthRefreshTokenMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *AuthRefreshTokenMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the AuthRefreshToken entity.
// If the AuthRefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRefreshTokenMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *AuthRefreshTokenMutation) ResetUserID() {
	m.user_id = nil
}

// SetApplicationID sets the "application_id" field.
func (m *AuthRefreshTokenMutation) SetApplicationID(s string) {
	m.application_id = &s
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *AuthRefreshTokenMutation) ApplicationID() (r string, exists bool) {
	v := m.application_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the AuthRefreshToken entity.
// If the AuthRefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRefreshTokenMutation) OldApplicationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *AuthRefreshTokenMutation) ResetApplicationID() {
	m.application_id = nil
}

// SetExpiration sets the "expiration" field.
func (m *AuthRefreshTokenMutation) SetExpiration(t time.Time) {
	m.expiration = &t
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *AuthRefreshTokenMutation) Expiration() (r time.Time, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the AuthRefreshToken entity.
// If the AuthRefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRefreshTokenMutation) OldExpiration(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *AuthRefreshTokenMutation) ResetExpiration() {
	m.expiration = nil
}

// SetScopes sets the "scopes" field.
func (m *AuthRefreshTokenMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *AuthRefreshTokenMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the AuthRefreshToken entity.
// If the AuthRefreshToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthRefreshTokenMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *AuthRefreshTokenMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *AuthRefreshTokenMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *AuthRefreshTokenMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// Where appends a list predicates to the AuthRefreshTokenMutation builder.
func (m *AuthRefreshTokenMutation) Where(ps ...predicate.AuthRefreshToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthRefreshTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthRefreshTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthRefreshToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthRefreshTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthRefreshTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthRefreshToken).
func (m *AuthRefreshTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthRefreshTokenMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m._Token != nil {
		fields = append(fields, authrefreshtoken.FieldToken)
	}
	if m.subject != nil {
		fields = append(fields, authrefreshtoken.FieldSubject)
	}
	if m.auth_time != nil {
		fields = append(fields, authrefreshtoken.FieldAuthTime)
	}
	if m.amr != nil {
		fields = append(fields, authrefreshtoken.FieldAmr)
	}
	if m.audience != nil {
		fields = append(fields, authrefreshtoken.FieldAudience)
	}
	if m.user_id != nil {
		fields = append(fields, authrefreshtoken.FieldUserID)
	}
	if m.application_id != nil {
		fields = append(fields, authrefreshtoken.FieldApplicationID)
	}
	if m.expiration != nil {
		fields = append(fields, authrefreshtoken.FieldExpiration)
	}
	if m.scopes != nil {
		fields = append(fields, authrefreshtoken.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthRefreshTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authrefreshtoken.FieldToken:
		return m.Token()
	case authrefreshtoken.FieldSubject:
		return m.Subject()
	case authrefreshtoken.FieldAuthTime:
		return m.AuthTime()
	case authrefreshtoken.FieldAmr:
		return m.Amr()
	case authrefreshtoken.FieldAudience:
		return m.Audience()
	case authrefreshtoken.FieldUserID:
		return m.UserID()
	case authrefreshtoken.FieldApplicationID:
		return m.ApplicationID()
	case authrefreshtoken.FieldExpiration:
		return m.Expiration()
	case authrefreshtoken.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthRefreshTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authrefreshtoken.FieldToken:
		return m.OldToken(ctx)
	case authrefreshtoken.FieldSubject:
		return m.OldSubject(ctx)
	case authrefreshtoken.FieldAuthTime:
		return m.OldAuthTime(ctx)
	case authrefreshtoken.FieldAmr:
		return m.OldAmr(ctx)
	case authrefreshtoken.FieldAudience:
		return m.OldAudience(ctx)
	case authrefreshtoken.FieldUserID:
		return m.OldUserID(ctx)
	case authrefreshtoken.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case authrefreshtoken.FieldExpiration:
		return m.OldExpiration(ctx)
	case authrefreshtoken.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown AuthRefreshToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRefreshTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authrefreshtoken.FieldToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToken(v)
		return nil
	case authrefreshtoken.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case authrefreshtoken.FieldAuthTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthTime(v)
		return nil
	case authrefreshtoken.FieldAmr:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAmr(v)
		return nil
	case authrefreshtoken.FieldAudience:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudience(v)
		return nil
	case authrefreshtoken.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case authrefreshtoken.FieldApplicationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case authrefreshtoken.FieldExpiration:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case authrefreshtoken.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown AuthRefreshToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthRefreshTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthRefreshTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthRefreshTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthRefreshToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthRefreshTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthRefreshTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthRefreshTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthRefreshToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthRefreshTokenMutation) ResetField(name string) error {
	switch name {
	case authrefreshtoken.FieldToken:
		m.ResetToken()
		return nil
	case authrefreshtoken.FieldSubject:
		m.ResetSubject()
		return nil
	case authrefreshtoken.FieldAuthTime:
		m.ResetAuthTime()
		return nil
	case authrefreshtoken.FieldAmr:
		m.ResetAmr()
		return nil
	case authrefreshtoken.FieldAudience:
		m.ResetAudience()
		return nil
	case authrefreshtoken.FieldUserID:
		m.ResetUserID()
		return nil
	case authrefreshtoken.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case authrefreshtoken.FieldExpiration:
		m.ResetExpiration()
		return nil
	case authrefreshtoken.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown AuthRefreshToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthRefreshTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthRefreshTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthRefreshTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthRefreshTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthRefreshTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthRefreshTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthRefreshTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthRefreshToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthRefreshTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthRefreshToken edge %s", name)
}

// AuthTokenMutation represents an operation that mutates the AuthToken nodes in the graph.
type AuthTokenMutation struct {
	config
	op               Op
	typ              string
	id               *string
	application_id   *string
	subject          *string
	refresh_token_id *string
	audience         *[]string
	appendaudience   []string
	expiration       *time.Time
	scopes           *[]string
	appendscopes     []string
	clearedFields    map[string]struct{}
	done             bool
	oldValue         func(context.Context) (*AuthToken, error)
	predicates       []predicate.AuthToken
}

var _ ent.Mutation = (*AuthTokenMutation)(nil)

// authtokenOption allows management of the mutation configuration using functional options.
type authtokenOption func(*AuthTokenMutation)

// newAuthTokenMutation creates new mutation for the AuthToken entity.
func newAuthTokenMutation(c config, op Op, opts ...authtokenOption) *AuthTokenMutation {
	m := &AuthTokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAuthToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAuthTokenID sets the ID field of the mutation.
func withAuthTokenID(id string) authtokenOption {
	return func(m *AuthTokenMutation) {
		var (
			err   error
			once  sync.Once
			value *AuthToken
		)
		m.oldValue = func(ctx context.Context) (*AuthToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AuthToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAuthToken sets the old AuthToken of the mutation.
func withAuthToken(node *AuthToken) authtokenOption {
	return func(m *AuthTokenMutation) {
		m.oldValue = func(context.Context) (*AuthToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AuthTokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AuthTokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AuthToken entities.
func (m *AuthTokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AuthTokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AuthTokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AuthToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetApplicationID sets the "application_id" field.
func (m *AuthTokenMutation) SetApplicationID(s string) {
	m.application_id = &s
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *AuthTokenMutation) ApplicationID() (r string, exists bool) {
	v := m.application_id
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldApplicationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *AuthTokenMutation) ResetApplicationID() {
	m.application_id = nil
}

// SetSubject sets the "subject" field.
func (m *AuthTokenMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *AuthTokenMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *AuthTokenMutation) ResetSubject() {
	m.subject = nil
}

// SetRefreshTokenID sets the "refresh_token_id" field.
func (m *AuthTokenMutation) SetRefreshTokenID(s string) {
	m.refresh_token_id = &s
}

// RefreshTokenID returns the value of the "refresh_token_id" field in the mutation.
func (m *AuthTokenMutation) RefreshTokenID() (r string, exists bool) {
	v := m.refresh_token_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRefreshTokenID returns the old "refresh_token_id" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldRefreshTokenID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRefreshTokenID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRefreshTokenID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRefreshTokenID: %w", err)
	}
	return oldValue.RefreshTokenID, nil
}

// ResetRefreshTokenID resets all changes to the "refresh_token_id" field.
func (m *AuthTokenMutation) ResetRefreshTokenID() {
	m.refresh_token_id = nil
}

// SetAudience sets the "audience" field.
func (m *AuthTokenMutation) SetAudience(s []string) {
	m.audience = &s
	m.appendaudience = nil
}

// Audience returns the value of the "audience" field in the mutation.
func (m *AuthTokenMutation) Audience() (r []string, exists bool) {
	v := m.audience
	if v == nil {
		return
	}
	return *v, true
}

// OldAudience returns the old "audience" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldAudience(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAudience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAudience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAudience: %w", err)
	}
	return oldValue.Audience, nil
}

// AppendAudience adds s to the "audience" field.
func (m *AuthTokenMutation) AppendAudience(s []string) {
	m.appendaudience = append(m.appendaudience, s...)
}

// AppendedAudience returns the list of values that were appended to the "audience" field in this mutation.
func (m *AuthTokenMutation) AppendedAudience() ([]string, bool) {
	if len(m.appendaudience) == 0 {
		return nil, false
	}
	return m.appendaudience, true
}

// ResetAudience resets all changes to the "audience" field.
func (m *AuthTokenMutation) ResetAudience() {
	m.audience = nil
	m.appendaudience = nil
}

// SetExpiration sets the "expiration" field.
func (m *AuthTokenMutation) SetExpiration(t time.Time) {
	m.expiration = &t
}

// Expiration returns the value of the "expiration" field in the mutation.
func (m *AuthTokenMutation) Expiration() (r time.Time, exists bool) {
	v := m.expiration
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiration returns the old "expiration" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldExpiration(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiration: %w", err)
	}
	return oldValue.Expiration, nil
}

// ResetExpiration resets all changes to the "expiration" field.
func (m *AuthTokenMutation) ResetExpiration() {
	m.expiration = nil
}

// SetScopes sets the "scopes" field.
func (m *AuthTokenMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *AuthTokenMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the AuthToken entity.
// If the AuthToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AuthTokenMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *AuthTokenMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *AuthTokenMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *AuthTokenMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// Where appends a list predicates to the AuthTokenMutation builder.
func (m *AuthTokenMutation) Where(ps ...predicate.AuthToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AuthTokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AuthTokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AuthToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AuthTokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AuthTokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AuthToken).
func (m *AuthTokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AuthTokenMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.application_id != nil {
		fields = append(fields, authtoken.FieldApplicationID)
	}
	if m.subject != nil {
		fields = append(fields, authtoken.FieldSubject)
	}
	if m.refresh_token_id != nil {
		fields = append(fields, authtoken.FieldRefreshTokenID)
	}
	if m.audience != nil {
		fields = append(fields, authtoken.FieldAudience)
	}
	if m.expiration != nil {
		fields = append(fields, authtoken.FieldExpiration)
	}
	if m.scopes != nil {
		fields = append(fields, authtoken.FieldScopes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AuthTokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case authtoken.FieldApplicationID:
		return m.ApplicationID()
	case authtoken.FieldSubject:
		return m.Subject()
	case authtoken.FieldRefreshTokenID:
		return m.RefreshTokenID()
	case authtoken.FieldAudience:
		return m.Audience()
	case authtoken.FieldExpiration:
		return m.Expiration()
	case authtoken.FieldScopes:
		return m.Scopes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AuthTokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case authtoken.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case authtoken.FieldSubject:
		return m.OldSubject(ctx)
	case authtoken.FieldRefreshTokenID:
		return m.OldRefreshTokenID(ctx)
	case authtoken.FieldAudience:
		return m.OldAudience(ctx)
	case authtoken.FieldExpiration:
		return m.OldExpiration(ctx)
	case authtoken.FieldScopes:
		return m.OldScopes(ctx)
	}
	return nil, fmt.Errorf("unknown AuthToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case authtoken.FieldApplicationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case authtoken.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case authtoken.FieldRefreshTokenID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRefreshTokenID(v)
		return nil
	case authtoken.FieldAudience:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAudience(v)
		return nil
	case authtoken.FieldExpiration:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiration(v)
		return nil
	case authtoken.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	}
	return fmt.Errorf("unknown AuthToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AuthTokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AuthTokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AuthTokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AuthToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AuthTokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AuthTokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AuthTokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AuthToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AuthTokenMutation) ResetField(name string) error {
	switch name {
	case authtoken.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case authtoken.FieldSubject:
		m.ResetSubject()
		return nil
	case authtoken.FieldRefreshTokenID:
		m.ResetRefreshTokenID()
		return nil
	case authtoken.FieldAudience:
		m.ResetAudience()
		return nil
	case authtoken.FieldExpiration:
		m.ResetExpiration()
		return nil
	case authtoken.FieldScopes:
		m.ResetScopes()
		return nil
	}
	return fmt.Errorf("unknown AuthToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AuthTokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AuthTokenMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AuthTokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AuthTokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AuthTokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AuthTokenMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AuthTokenMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown AuthToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AuthTokenMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown AuthToken edge %s", name)
}

// ComponentMutation represents an operation that mutates the Component nodes in the graph.
type ComponentMutation struct {
	config
	op                Op
	typ               string
	id                *int
	name              *string
	description       *string
	image_url         *string
	color             *string
	clearedFields     map[string]struct{}
	vote              *int
	clearedvote       bool
	user_votes        map[int]struct{}
	removeduser_votes map[int]struct{}
	cleareduser_votes bool
	done              bool
	oldValue          func(context.Context) (*Component, error)
	predicates        []predicate.Component
}

var _ ent.Mutation = (*ComponentMutation)(nil)

// componentOption allows management of the mutation configuration using functional options.
type componentOption func(*ComponentMutation)

// newComponentMutation creates new mutation for the Component entity.
func newComponentMutation(c config, op Op, opts ...componentOption) *ComponentMutation {
	m := &ComponentMutation{
		config:        c,
		op:            op,
		typ:           TypeComponent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withComponentID sets the ID field of the mutation.
func withComponentID(id int) componentOption {
	return func(m *ComponentMutation) {
		var (
			err   error
			once  sync.Once
			value *Component
		)
		m.oldValue = func(ctx context.Context) (*Component, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Component.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withComponent sets the old Component of the mutation.
func withComponent(node *Component) componentOption {
	return func(m *ComponentMutation) {
		m.oldValue = func(context.Context) (*Component, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ComponentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ComponentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ComponentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ComponentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Component.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ComponentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ComponentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ComponentMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ComponentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ComponentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ComponentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[component.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ComponentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[component.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ComponentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, component.FieldDescription)
}

// SetImageURL sets the "image_url" field.
func (m *ComponentMutation) SetImageURL(s string) {
	m.image_url = &s
}

// ImageURL returns the value of the "image_url" field in the mutation.
func (m *ComponentMutation) ImageURL() (r string, exists bool) {
	v := m.image_url
	if v == nil {
		return
	}
	return *v, true
}

// OldImageURL returns the old "image_url" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldImageURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImageURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImageURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImageURL: %w", err)
	}
	return oldValue.ImageURL, nil
}

// ResetImageURL resets all changes to the "image_url" field.
func (m *ComponentMutation) ResetImageURL() {
	m.image_url = nil
}

// SetColor sets the "color" field.
func (m *ComponentMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *ComponentMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Component entity.
// If the Component object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ComponentMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *ComponentMutation) ClearColor() {
	m.color = nil
	m.clearedFields[component.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *ComponentMutation) ColorCleared() bool {
	_, ok := m.clearedFields[component.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *ComponentMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, component.FieldColor)
}

// SetVoteID sets the "vote" edge to the Vote entity by id.
func (m *ComponentMutation) SetVoteID(id int) {
	m.vote = &id
}

// ClearVote clears the "vote" edge to the Vote entity.
func (m *ComponentMutation) ClearVote() {
	m.clearedvote = true
}

// VoteCleared reports if the "vote" edge to the Vote entity was cleared.
func (m *ComponentMutation) VoteCleared() bool {
	return m.clearedvote
}

// VoteID returns the "vote" edge ID in the mutation.
func (m *ComponentMutation) VoteID() (id int, exists bool) {
	if m.vote != nil {
		return *m.vote, true
	}
	return
}

// VoteIDs returns the "vote" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VoteID instead. It exists only for internal usage by the builders.
func (m *ComponentMutation) VoteIDs() (ids []int) {
	if id := m.vote; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVote resets all changes to the "vote" edge.
func (m *ComponentMutation) ResetVote() {
	m.vote = nil
	m.clearedvote = false
}

// AddUserVoteIDs adds the "user_votes" edge to the UserVote entity by ids.
func (m *ComponentMutation) AddUserVoteIDs(ids ...int) {
	if m.user_votes == nil {
		m.user_votes = make(map[int]struct{})
	}
	for i := range ids {
		m.user_votes[ids[i]] = struct{}{}
	}
}

// ClearUserVotes clears the "user_votes" edge to the UserVote entity.
func (m *ComponentMutation) ClearUserVotes() {
	m.cleareduser_votes = true
}

// UserVotesCleared reports if the "user_votes" edge to the UserVote entity was cleared.
func (m *ComponentMutation) UserVotesCleared() bool {
	return m.cleareduser_votes
}

// RemoveUserVoteIDs removes the "user_votes" edge to the UserVote entity by IDs.
func (m *ComponentMutation) RemoveUserVoteIDs(ids ...int) {
	if m.removeduser_votes == nil {
		m.removeduser_votes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_votes, ids[i])
		m.removeduser_votes[ids[i]] = struct{}{}
	}
}

// RemovedUserVotes returns the removed IDs of the "user_votes" edge to the UserVote entity.
func (m *ComponentMutation) RemovedUserVotesIDs() (ids []int) {
	for id := range m.removeduser_votes {
		ids = append(ids, id)
	}
	return
}

// UserVotesIDs returns the "user_votes" edge IDs in the mutation.
func (m *ComponentMutation) UserVotesIDs() (ids []int) {
	for id := range m.user_votes {
		ids = append(ids, id)
	}
	return
}

// ResetUserVotes resets all changes to the "user_votes" edge.
func (m *ComponentMutation) ResetUserVotes() {
	m.user_votes = nil
	m.cleareduser_votes = false
	m.removeduser_votes = nil
}

// Where appends a list predicates to the ComponentMutation builder.
func (m *ComponentMutation) Where(ps ...predicate.Component) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ComponentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ComponentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Component, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ComponentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ComponentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Component).
func (m *ComponentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ComponentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, component.FieldName)
	}
	if m.description != nil {
		fields = append(fields, component.FieldDescription)
	}
	if m.image_url != nil {
		fields = append(fields, component.FieldImageURL)
	}
	if m.color != nil {
		fields = append(fields, component.FieldColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ComponentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case component.FieldName:
		return m.Name()
	case component.FieldDescription:
		return m.Description()
	case component.FieldImageURL:
		return m.ImageURL()
	case component.FieldColor:
		return m.Color()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ComponentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case component.FieldName:
		return m.OldName(ctx)
	case component.FieldDescription:
		return m.OldDescription(ctx)
	case component.FieldImageURL:
		return m.OldImageURL(ctx)
	case component.FieldColor:
		return m.OldColor(ctx)
	}
	return nil, fmt.Errorf("unknown Component field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case component.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case component.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case component.FieldImageURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImageURL(v)
		return nil
	case component.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ComponentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ComponentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ComponentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Component numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ComponentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(component.FieldDescription) {
		fields = append(fields, component.FieldDescription)
	}
	if m.FieldCleared(component.FieldColor) {
		fields = append(fields, component.FieldColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ComponentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ComponentMutation) ClearField(name string) error {
	switch name {
	case component.FieldDescription:
		m.ClearDescription()
		return nil
	case component.FieldColor:
		m.ClearColor()
		return nil
	}
	return fmt.Errorf("unknown Component nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ComponentMutation) ResetField(name string) error {
	switch name {
	case component.FieldName:
		m.ResetName()
		return nil
	case component.FieldDescription:
		m.ResetDescription()
		return nil
	case component.FieldImageURL:
		m.ResetImageURL()
		return nil
	case component.FieldColor:
		m.ResetColor()
		return nil
	}
	return fmt.Errorf("unknown Component field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ComponentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.vote != nil {
		edges = append(edges, component.EdgeVote)
	}
	if m.user_votes != nil {
		edges = append(edges, component.EdgeUserVotes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ComponentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case component.EdgeVote:
		if id := m.vote; id != nil {
			return []ent.Value{*id}
		}
	case component.EdgeUserVotes:
		ids := make([]ent.Value, 0, len(m.user_votes))
		for id := range m.user_votes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ComponentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeduser_votes != nil {
		edges = append(edges, component.EdgeUserVotes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ComponentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case component.EdgeUserVotes:
		ids := make([]ent.Value, 0, len(m.removeduser_votes))
		for id := range m.removeduser_votes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ComponentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedvote {
		edges = append(edges, component.EdgeVote)
	}
	if m.cleareduser_votes {
		edges = append(edges, component.EdgeUserVotes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ComponentMutation) EdgeCleared(name string) bool {
	switch name {
	case component.EdgeVote:
		return m.clearedvote
	case component.EdgeUserVotes:
		return m.cleareduser_votes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ComponentMutation) ClearEdge(name string) error {
	switch name {
	case component.EdgeVote:
		m.ClearVote()
		return nil
	}
	return fmt.Errorf("unknown Component unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ComponentMutation) ResetEdge(name string) error {
	switch name {
	case component.EdgeVote:
		m.ResetVote()
		return nil
	case component.EdgeUserVotes:
		m.ResetUserVotes()
		return nil
	}
	return fmt.Errorf("unknown Component edge %s", name)
}

// ConsentMutation represents an operation that mutates the Consent nodes in the graph.
type ConsentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	created_at         *time.Time
	updated_at         *time.Time
	scopes             *[]string
	appendscopes       []string
	expiration_date    *time.Time
	clearedFields      map[string]struct{}
	application        *string
	clearedapplication bool
	user               *int
	cleareduser        bool
	done               bool
	oldValue           func(context.Context) (*Consent, error)
	predicates         []predicate.Consent
}

var _ ent.Mutation = (*ConsentMutation)(nil)

// consentOption allows management of the mutation configuration using functional options.
type consentOption func(*ConsentMutation)

// newConsentMutation creates new mutation for the Consent entity.
func newConsentMutation(c config, op Op, opts ...consentOption) *ConsentMutation {
	m := &ConsentMutation{
		config:        c,
		op:            op,
		typ:           TypeConsent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConsentID sets the ID field of the mutation.
func withConsentID(id int) consentOption {
	return func(m *ConsentMutation) {
		var (
			err   error
			once  sync.Once
			value *Consent
		)
		m.oldValue = func(ctx context.Context) (*Consent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Consent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConsent sets the old Consent of the mutation.
func withConsent(node *Consent) consentOption {
	return func(m *ConsentMutation) {
		m.oldValue = func(context.Context) (*Consent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConsentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConsentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Consent entities.
func (m *ConsentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConsentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConsentMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Consent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ConsentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConsentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Consent entity.
// If the Consent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConsentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ConsentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ConsentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Consent entity.
// If the Consent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ConsentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetApplicationID sets the "application_id" field.
func (m *ConsentMutation) SetApplicationID(s string) {
	m.application = &s
}

// ApplicationID returns the value of the "application_id" field in the mutation.
func (m *ConsentMutation) ApplicationID() (r string, exists bool) {
	v := m.application
	if v == nil {
		return
	}
	return *v, true
}

// OldApplicationID returns the old "application_id" field's value of the Consent entity.
// If the Consent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentMutation) OldApplicationID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldApplicationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldApplicationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplicationID: %w", err)
	}
	return oldValue.ApplicationID, nil
}

// ResetApplicationID resets all changes to the "application_id" field.
func (m *ConsentMutation) ResetApplicationID() {
	m.application = nil
}

// SetUserID sets the "user_id" field.
func (m *ConsentMutation) SetUserID(i int) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *ConsentMutation) UserID() (r int, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Consent entity.
// If the Consent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentMutation) OldUserID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *ConsentMutation) ResetUserID() {
	m.user = nil
}

// SetScopes sets the "scopes" field.
func (m *ConsentMutation) SetScopes(s []string) {
	m.scopes = &s
	m.appendscopes = nil
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *ConsentMutation) Scopes() (r []string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the Consent entity.
// If the Consent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentMutation) OldScopes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// AppendScopes adds s to the "scopes" field.
func (m *ConsentMutation) AppendScopes(s []string) {
	m.appendscopes = append(m.appendscopes, s...)
}

// AppendedScopes returns the list of values that were appended to the "scopes" field in this mutation.
func (m *ConsentMutation) AppendedScopes() ([]string, bool) {
	if len(m.appendscopes) == 0 {
		return nil, false
	}
	return m.appendscopes, true
}

// ResetScopes resets all changes to the "scopes" field.
func (m *ConsentMutation) ResetScopes() {
	m.scopes = nil
	m.appendscopes = nil
}

// SetExpirationDate sets the "expiration_date" field.
func (m *ConsentMutation) SetExpirationDate(t time.Time) {
	m.expiration_date = &t
}

// ExpirationDate returns the value of the "expiration_date" field in the mutation.
func (m *ConsentMutation) ExpirationDate() (r time.Time, exists bool) {
	v := m.expiration_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpirationDate returns the old "expiration_date" field's value of the Consent entity.
// If the Consent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsentMutation) OldExpirationDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpirationDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpirationDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpirationDate: %w", err)
	}
	return oldValue.ExpirationDate, nil
}

// ResetExpirationDate resets all changes to the "expiration_date" field.
func (m *ConsentMutation) ResetExpirationDate() {
	m.expiration_date = nil
}

// ClearApplication clears the "application" edge to the App entity.
func (m *ConsentMutation) ClearApplication() {
	m.clearedapplication = true
	m.clearedFields[consent.FieldApplicationID] = struct{}{}
}

// ApplicationCleared reports if the "application" edge to the App entity was cleared.
func (m *ConsentMutation) ApplicationCleared() bool {
	return m.clearedapplication
}

// ApplicationIDs returns the "application" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ApplicationID instead. It exists only for internal usage by the builders.
func (m *ConsentMutation) ApplicationIDs() (ids []string) {
	if id := m.application; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApplication resets all changes to the "application" edge.
func (m *ConsentMutation) ResetApplication() {
	m.application = nil
	m.clearedapplication = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *ConsentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[consent.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ConsentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ConsentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ConsentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the ConsentMutation builder.
func (m *ConsentMutation) Where(ps ...predicate.Consent) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConsentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConsentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Consent, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConsentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConsentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Consent).
func (m *ConsentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConsentMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, consent.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, consent.FieldUpdatedAt)
	}
	if m.application != nil {
		fields = append(fields, consent.FieldApplicationID)
	}
	if m.user != nil {
		fields = append(fields, consent.FieldUserID)
	}
	if m.scopes != nil {
		fields = append(fields, consent.FieldScopes)
	}
	if m.expiration_date != nil {
		fields = append(fields, consent.FieldExpirationDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConsentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case consent.FieldCreatedAt:
		return m.CreatedAt()
	case consent.FieldUpdatedAt:
		return m.UpdatedAt()
	case consent.FieldApplicationID:
		return m.ApplicationID()
	case consent.FieldUserID:
		return m.UserID()
	case consent.FieldScopes:
		return m.Scopes()
	case consent.FieldExpirationDate:
		return m.ExpirationDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConsentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case consent.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case consent.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case consent.FieldApplicationID:
		return m.OldApplicationID(ctx)
	case consent.FieldUserID:
		return m.OldUserID(ctx)
	case consent.FieldScopes:
		return m.OldScopes(ctx)
	case consent.FieldExpirationDate:
		return m.OldExpirationDate(ctx)
	}
	return nil, fmt.Errorf("unknown Consent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case consent.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case consent.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case consent.FieldApplicationID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplicationID(v)
		return nil
	case consent.FieldUserID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case consent.FieldScopes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case consent.FieldExpirationDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpirationDate(v)
		return nil
	}
	return fmt.Errorf("unknown Consent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConsentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConsentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Consent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConsentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConsentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConsentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Consent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConsentMutation) ResetField(name string) error {
	switch name {
	case consent.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case consent.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case consent.FieldApplicationID:
		m.ResetApplicationID()
		return nil
	case consent.FieldUserID:
		m.ResetUserID()
		return nil
	case consent.FieldScopes:
		m.ResetScopes()
		return nil
	case consent.FieldExpirationDate:
		m.ResetExpirationDate()
		return nil
	}
	return fmt.Errorf("unknown Consent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConsentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.application != nil {
		edges = append(edges, consent.EdgeApplication)
	}
	if m.user != nil {
		edges = append(edges, consent.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConsentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case consent.EdgeApplication:
		if id := m.application; id != nil {
			return []ent.Value{*id}
		}
	case consent.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConsentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConsentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConsentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapplication {
		edges = append(edges, consent.EdgeApplication)
	}
	if m.cleareduser {
		edges = append(edges, consent.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConsentMutation) EdgeCleared(name string) bool {
	switch name {
	case consent.EdgeApplication:
		return m.clearedapplication
	case consent.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConsentMutation) ClearEdge(name string) error {
	switch name {
	case consent.EdgeApplication:
		m.ClearApplication()
		return nil
	case consent.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Consent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConsentMutation) ResetEdge(name string) error {
	switch name {
	case consent.EdgeApplication:
		m.ResetApplication()
		return nil
	case consent.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Consent edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	username             *string
	first_name           *string
	last_name            *string
	email                *string
	created_at           *time.Time
	updated_at           *time.Time
	picture              *string
	kind                 *user.Kind
	usual_full_name      *string
	usual_first_name     *string
	roles                *[]string
	appendroles          []string
	clearedFields        map[string]struct{}
	user_votes           map[int]struct{}
	removeduser_votes    map[int]struct{}
	cleareduser_votes    bool
	created_votes        map[int]struct{}
	removedcreated_votes map[int]struct{}
	clearedcreated_votes bool
	apps                 map[string]struct{}
	removedapps          map[string]struct{}
	clearedapps          bool
	consents             map[int]struct{}
	removedconsents      map[int]struct{}
	clearedconsents      bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
	predicates           []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetPicture sets the "picture" field.
func (m *UserMutation) SetPicture(s string) {
	m.picture = &s
}

// Picture returns the value of the "picture" field in the mutation.
func (m *UserMutation) Picture() (r string, exists bool) {
	v := m.picture
	if v == nil {
		return
	}
	return *v, true
}

// OldPicture returns the old "picture" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPicture(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPicture is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPicture requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPicture: %w", err)
	}
	return oldValue.Picture, nil
}

// ClearPicture clears the value of the "picture" field.
func (m *UserMutation) ClearPicture() {
	m.picture = nil
	m.clearedFields[user.FieldPicture] = struct{}{}
}

// PictureCleared returns if the "picture" field was cleared in this mutation.
func (m *UserMutation) PictureCleared() bool {
	_, ok := m.clearedFields[user.FieldPicture]
	return ok
}

// ResetPicture resets all changes to the "picture" field.
func (m *UserMutation) ResetPicture() {
	m.picture = nil
	delete(m.clearedFields, user.FieldPicture)
}

// SetKind sets the "kind" field.
func (m *UserMutation) SetKind(u user.Kind) {
	m.kind = &u
}

// Kind returns the value of the "kind" field in the mutation.
func (m *UserMutation) Kind() (r user.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldKind(ctx context.Context) (v user.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *UserMutation) ResetKind() {
	m.kind = nil
}

// SetUsualFullName sets the "usual_full_name" field.
func (m *UserMutation) SetUsualFullName(s string) {
	m.usual_full_name = &s
}

// UsualFullName returns the value of the "usual_full_name" field in the mutation.
func (m *UserMutation) UsualFullName() (r string, exists bool) {
	v := m.usual_full_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUsualFullName returns the old "usual_full_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsualFullName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsualFullName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsualFullName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsualFullName: %w", err)
	}
	return oldValue.UsualFullName, nil
}

// ResetUsualFullName resets all changes to the "usual_full_name" field.
func (m *UserMutation) ResetUsualFullName() {
	m.usual_full_name = nil
}

// SetUsualFirstName sets the "usual_first_name" field.
func (m *UserMutation) SetUsualFirstName(s string) {
	m.usual_first_name = &s
}

// UsualFirstName returns the value of the "usual_first_name" field in the mutation.
func (m *UserMutation) UsualFirstName() (r string, exists bool) {
	v := m.usual_first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUsualFirstName returns the old "usual_first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsualFirstName(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsualFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsualFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsualFirstName: %w", err)
	}
	return oldValue.UsualFirstName, nil
}

// ClearUsualFirstName clears the value of the "usual_first_name" field.
func (m *UserMutation) ClearUsualFirstName() {
	m.usual_first_name = nil
	m.clearedFields[user.FieldUsualFirstName] = struct{}{}
}

// UsualFirstNameCleared returns if the "usual_first_name" field was cleared in this mutation.
func (m *UserMutation) UsualFirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldUsualFirstName]
	return ok
}

// ResetUsualFirstName resets all changes to the "usual_first_name" field.
func (m *UserMutation) ResetUsualFirstName() {
	m.usual_first_name = nil
	delete(m.clearedFields, user.FieldUsualFirstName)
}

// SetRoles sets the "roles" field.
func (m *UserMutation) SetRoles(s []string) {
	m.roles = &s
	m.appendroles = nil
}

// Roles returns the value of the "roles" field in the mutation.
func (m *UserMutation) Roles() (r []string, exists bool) {
	v := m.roles
	if v == nil {
		return
	}
	return *v, true
}

// OldRoles returns the old "roles" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoles(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoles is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoles requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoles: %w", err)
	}
	return oldValue.Roles, nil
}

// AppendRoles adds s to the "roles" field.
func (m *UserMutation) AppendRoles(s []string) {
	m.appendroles = append(m.appendroles, s...)
}

// AppendedRoles returns the list of values that were appended to the "roles" field in this mutation.
func (m *UserMutation) AppendedRoles() ([]string, bool) {
	if len(m.appendroles) == 0 {
		return nil, false
	}
	return m.appendroles, true
}

// ResetRoles resets all changes to the "roles" field.
func (m *UserMutation) ResetRoles() {
	m.roles = nil
	m.appendroles = nil
}

// AddUserVoteIDs adds the "user_votes" edge to the UserVote entity by ids.
func (m *UserMutation) AddUserVoteIDs(ids ...int) {
	if m.user_votes == nil {
		m.user_votes = make(map[int]struct{})
	}
	for i := range ids {
		m.user_votes[ids[i]] = struct{}{}
	}
}

// ClearUserVotes clears the "user_votes" edge to the UserVote entity.
func (m *UserMutation) ClearUserVotes() {
	m.cleareduser_votes = true
}

// UserVotesCleared reports if the "user_votes" edge to the UserVote entity was cleared.
func (m *UserMutation) UserVotesCleared() bool {
	return m.cleareduser_votes
}

// RemoveUserVoteIDs removes the "user_votes" edge to the UserVote entity by IDs.
func (m *UserMutation) RemoveUserVoteIDs(ids ...int) {
	if m.removeduser_votes == nil {
		m.removeduser_votes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.user_votes, ids[i])
		m.removeduser_votes[ids[i]] = struct{}{}
	}
}

// RemovedUserVotes returns the removed IDs of the "user_votes" edge to the UserVote entity.
func (m *UserMutation) RemovedUserVotesIDs() (ids []int) {
	for id := range m.removeduser_votes {
		ids = append(ids, id)
	}
	return
}

// UserVotesIDs returns the "user_votes" edge IDs in the mutation.
func (m *UserMutation) UserVotesIDs() (ids []int) {
	for id := range m.user_votes {
		ids = append(ids, id)
	}
	return
}

// ResetUserVotes resets all changes to the "user_votes" edge.
func (m *UserMutation) ResetUserVotes() {
	m.user_votes = nil
	m.cleareduser_votes = false
	m.removeduser_votes = nil
}

// AddCreatedVoteIDs adds the "created_votes" edge to the Vote entity by ids.
func (m *UserMutation) AddCreatedVoteIDs(ids ...int) {
	if m.created_votes == nil {
		m.created_votes = make(map[int]struct{})
	}
	for i := range ids {
		m.created_votes[ids[i]] = struct{}{}
	}
}

// ClearCreatedVotes clears the "created_votes" edge to the Vote entity.
func (m *UserMutation) ClearCreatedVotes() {
	m.clearedcreated_votes = true
}

// CreatedVotesCleared reports if the "created_votes" edge to the Vote entity was cleared.
func (m *UserMutation) CreatedVotesCleared() bool {
	return m.clearedcreated_votes
}

// RemoveCreatedVoteIDs removes the "created_votes" edge to the Vote entity by IDs.
func (m *UserMutation) RemoveCreatedVoteIDs(ids ...int) {
	if m.removedcreated_votes == nil {
		m.removedcreated_votes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.created_votes, ids[i])
		m.removedcreated_votes[ids[i]] = struct{}{}
	}
}

// RemovedCreatedVotes returns the removed IDs of the "created_votes" edge to the Vote entity.
func (m *UserMutation) RemovedCreatedVotesIDs() (ids []int) {
	for id := range m.removedcreated_votes {
		ids = append(ids, id)
	}
	return
}

// CreatedVotesIDs returns the "created_votes" edge IDs in the mutation.
func (m *UserMutation) CreatedVotesIDs() (ids []int) {
	for id := range m.created_votes {
		ids = append(ids, id)
	}
	return
}

// ResetCreatedVotes resets all changes to the "created_votes" edge.
func (m *UserMutation) ResetCreatedVotes() {
	m.created_votes = nil
	m.clearedcreated_votes = false
	m.removedcreated_votes = nil
}

// AddAppIDs adds the "apps" edge to the App entity by ids.
func (m *UserMutation) AddAppIDs(ids ...string) {
	if m.apps == nil {
		m.apps = make(map[string]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the App entity.
func (m *UserMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the App entity was cleared.
func (m *UserMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the App entity by IDs.
func (m *UserMutation) RemoveAppIDs(ids ...string) {
	if m.removedapps == nil {
		m.removedapps = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the App entity.
func (m *UserMutation) RemovedAppsIDs() (ids []string) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *UserMutation) AppsIDs() (ids []string) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *UserMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// AddConsentIDs adds the "consents" edge to the Consent entity by ids.
func (m *UserMutation) AddConsentIDs(ids ...int) {
	if m.consents == nil {
		m.consents = make(map[int]struct{})
	}
	for i := range ids {
		m.consents[ids[i]] = struct{}{}
	}
}

// ClearConsents clears the "consents" edge to the Consent entity.
func (m *UserMutation) ClearConsents() {
	m.clearedconsents = true
}

// ConsentsCleared reports if the "consents" edge to the Consent entity was cleared.
func (m *UserMutation) ConsentsCleared() bool {
	return m.clearedconsents
}

// RemoveConsentIDs removes the "consents" edge to the Consent entity by IDs.
func (m *UserMutation) RemoveConsentIDs(ids ...int) {
	if m.removedconsents == nil {
		m.removedconsents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.consents, ids[i])
		m.removedconsents[ids[i]] = struct{}{}
	}
}

// RemovedConsents returns the removed IDs of the "consents" edge to the Consent entity.
func (m *UserMutation) RemovedConsentsIDs() (ids []int) {
	for id := range m.removedconsents {
		ids = append(ids, id)
	}
	return
}

// ConsentsIDs returns the "consents" edge IDs in the mutation.
func (m *UserMutation) ConsentsIDs() (ids []int) {
	for id := range m.consents {
		ids = append(ids, id)
	}
	return
}

// ResetConsents resets all changes to the "consents" edge.
func (m *UserMutation) ResetConsents() {
	m.consents = nil
	m.clearedconsents = false
	m.removedconsents = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.picture != nil {
		fields = append(fields, user.FieldPicture)
	}
	if m.kind != nil {
		fields = append(fields, user.FieldKind)
	}
	if m.usual_full_name != nil {
		fields = append(fields, user.FieldUsualFullName)
	}
	if m.usual_first_name != nil {
		fields = append(fields, user.FieldUsualFirstName)
	}
	if m.roles != nil {
		fields = append(fields, user.FieldRoles)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldUsername:
		return m.Username()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldEmail:
		return m.Email()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldPicture:
		return m.Picture()
	case user.FieldKind:
		return m.Kind()
	case user.FieldUsualFullName:
		return m.UsualFullName()
	case user.FieldUsualFirstName:
		return m.UsualFirstName()
	case user.FieldRoles:
		return m.Roles()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldPicture:
		return m.OldPicture(ctx)
	case user.FieldKind:
		return m.OldKind(ctx)
	case user.FieldUsualFullName:
		return m.OldUsualFullName(ctx)
	case user.FieldUsualFirstName:
		return m.OldUsualFirstName(ctx)
	case user.FieldRoles:
		return m.OldRoles(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldPicture:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPicture(v)
		return nil
	case user.FieldKind:
		v, ok := value.(user.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case user.FieldUsualFullName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsualFullName(v)
		return nil
	case user.FieldUsualFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsualFirstName(v)
		return nil
	case user.FieldRoles:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoles(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldPicture) {
		fields = append(fields, user.FieldPicture)
	}
	if m.FieldCleared(user.FieldUsualFirstName) {
		fields = append(fields, user.FieldUsualFirstName)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldPicture:
		m.ClearPicture()
		return nil
	case user.FieldUsualFirstName:
		m.ClearUsualFirstName()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldPicture:
		m.ResetPicture()
		return nil
	case user.FieldKind:
		m.ResetKind()
		return nil
	case user.FieldUsualFullName:
		m.ResetUsualFullName()
		return nil
	case user.FieldUsualFirstName:
		m.ResetUsualFirstName()
		return nil
	case user.FieldRoles:
		m.ResetRoles()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user_votes != nil {
		edges = append(edges, user.EdgeUserVotes)
	}
	if m.created_votes != nil {
		edges = append(edges, user.EdgeCreatedVotes)
	}
	if m.apps != nil {
		edges = append(edges, user.EdgeApps)
	}
	if m.consents != nil {
		edges = append(edges, user.EdgeConsents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserVotes:
		ids := make([]ent.Value, 0, len(m.user_votes))
		for id := range m.user_votes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedVotes:
		ids := make([]ent.Value, 0, len(m.created_votes))
		for id := range m.created_votes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConsents:
		ids := make([]ent.Value, 0, len(m.consents))
		for id := range m.consents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeduser_votes != nil {
		edges = append(edges, user.EdgeUserVotes)
	}
	if m.removedcreated_votes != nil {
		edges = append(edges, user.EdgeCreatedVotes)
	}
	if m.removedapps != nil {
		edges = append(edges, user.EdgeApps)
	}
	if m.removedconsents != nil {
		edges = append(edges, user.EdgeConsents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeUserVotes:
		ids := make([]ent.Value, 0, len(m.removeduser_votes))
		for id := range m.removeduser_votes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCreatedVotes:
		ids := make([]ent.Value, 0, len(m.removedcreated_votes))
		for id := range m.removedcreated_votes {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeConsents:
		ids := make([]ent.Value, 0, len(m.removedconsents))
		for id := range m.removedconsents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser_votes {
		edges = append(edges, user.EdgeUserVotes)
	}
	if m.clearedcreated_votes {
		edges = append(edges, user.EdgeCreatedVotes)
	}
	if m.clearedapps {
		edges = append(edges, user.EdgeApps)
	}
	if m.clearedconsents {
		edges = append(edges, user.EdgeConsents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeUserVotes:
		return m.cleareduser_votes
	case user.EdgeCreatedVotes:
		return m.clearedcreated_votes
	case user.EdgeApps:
		return m.clearedapps
	case user.EdgeConsents:
		return m.clearedconsents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeUserVotes:
		m.ResetUserVotes()
		return nil
	case user.EdgeCreatedVotes:
		m.ResetCreatedVotes()
		return nil
	case user.EdgeApps:
		m.ResetApps()
		return nil
	case user.EdgeConsents:
		m.ResetConsents()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserVoteMutation represents an operation that mutates the UserVote nodes in the graph.
type UserVoteMutation struct {
	config
	op               Op
	typ              string
	id               *int
	created_at       *time.Time
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	component        *int
	clearedcomponent bool
	done             bool
	oldValue         func(context.Context) (*UserVote, error)
	predicates       []predicate.UserVote
}

var _ ent.Mutation = (*UserVoteMutation)(nil)

// uservoteOption allows management of the mutation configuration using functional options.
type uservoteOption func(*UserVoteMutation)

// newUserVoteMutation creates new mutation for the UserVote entity.
func newUserVoteMutation(c config, op Op, opts ...uservoteOption) *UserVoteMutation {
	m := &UserVoteMutation{
		config:        c,
		op:            op,
		typ:           TypeUserVote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserVoteID sets the ID field of the mutation.
func withUserVoteID(id int) uservoteOption {
	return func(m *UserVoteMutation) {
		var (
			err   error
			once  sync.Once
			value *UserVote
		)
		m.oldValue = func(ctx context.Context) (*UserVote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserVote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserVote sets the old UserVote of the mutation.
func withUserVote(node *UserVote) uservoteOption {
	return func(m *UserVoteMutation) {
		m.oldValue = func(context.Context) (*UserVote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserVoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserVoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserVoteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserVoteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserVote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserVoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserVoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserVote entity.
// If the UserVote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserVoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserVoteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *UserVoteMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *UserVoteMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *UserVoteMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *UserVoteMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserVoteMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *UserVoteMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetComponentID sets the "component" edge to the Component entity by id.
func (m *UserVoteMutation) SetComponentID(id int) {
	m.component = &id
}

// ClearComponent clears the "component" edge to the Component entity.
func (m *UserVoteMutation) ClearComponent() {
	m.clearedcomponent = true
}

// ComponentCleared reports if the "component" edge to the Component entity was cleared.
func (m *UserVoteMutation) ComponentCleared() bool {
	return m.clearedcomponent
}

// ComponentID returns the "component" edge ID in the mutation.
func (m *UserVoteMutation) ComponentID() (id int, exists bool) {
	if m.component != nil {
		return *m.component, true
	}
	return
}

// ComponentIDs returns the "component" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ComponentID instead. It exists only for internal usage by the builders.
func (m *UserVoteMutation) ComponentIDs() (ids []int) {
	if id := m.component; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetComponent resets all changes to the "component" edge.
func (m *UserVoteMutation) ResetComponent() {
	m.component = nil
	m.clearedcomponent = false
}

// Where appends a list predicates to the UserVoteMutation builder.
func (m *UserVoteMutation) Where(ps ...predicate.UserVote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserVoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserVoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserVote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserVoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserVoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserVote).
func (m *UserVoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserVoteMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created_at != nil {
		fields = append(fields, uservote.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserVoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case uservote.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserVoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case uservote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserVote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserVoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case uservote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserVote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserVoteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserVoteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserVoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserVote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserVoteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserVoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserVoteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UserVote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserVoteMutation) ResetField(name string) error {
	switch name {
	case uservote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserVote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserVoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, uservote.EdgeUser)
	}
	if m.component != nil {
		edges = append(edges, uservote.EdgeComponent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserVoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case uservote.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case uservote.EdgeComponent:
		if id := m.component; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserVoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserVoteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserVoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, uservote.EdgeUser)
	}
	if m.clearedcomponent {
		edges = append(edges, uservote.EdgeComponent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserVoteMutation) EdgeCleared(name string) bool {
	switch name {
	case uservote.EdgeUser:
		return m.cleareduser
	case uservote.EdgeComponent:
		return m.clearedcomponent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserVoteMutation) ClearEdge(name string) error {
	switch name {
	case uservote.EdgeUser:
		m.ClearUser()
		return nil
	case uservote.EdgeComponent:
		m.ClearComponent()
		return nil
	}
	return fmt.Errorf("unknown UserVote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserVoteMutation) ResetEdge(name string) error {
	switch name {
	case uservote.EdgeUser:
		m.ResetUser()
		return nil
	case uservote.EdgeComponent:
		m.ResetComponent()
		return nil
	}
	return fmt.Errorf("unknown UserVote edge %s", name)
}

// VoteMutation represents an operation that mutates the Vote nodes in the graph.
type VoteMutation struct {
	config
	op                Op
	typ               string
	id                *int
	title             *string
	description       *string
	visible           *bool
	start_at          *time.Time
	end_at            *time.Time
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	components        map[int]struct{}
	removedcomponents map[int]struct{}
	clearedcomponents bool
	creator           *int
	clearedcreator    bool
	done              bool
	oldValue          func(context.Context) (*Vote, error)
	predicates        []predicate.Vote
}

var _ ent.Mutation = (*VoteMutation)(nil)

// voteOption allows management of the mutation configuration using functional options.
type voteOption func(*VoteMutation)

// newVoteMutation creates new mutation for the Vote entity.
func newVoteMutation(c config, op Op, opts ...voteOption) *VoteMutation {
	m := &VoteMutation{
		config:        c,
		op:            op,
		typ:           TypeVote,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVoteID sets the ID field of the mutation.
func withVoteID(id int) voteOption {
	return func(m *VoteMutation) {
		var (
			err   error
			once  sync.Once
			value *Vote
		)
		m.oldValue = func(ctx context.Context) (*Vote, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vote.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVote sets the old Vote of the mutation.
func withVote(node *Vote) voteOption {
	return func(m *VoteMutation) {
		m.oldValue = func(context.Context) (*Vote, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VoteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VoteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VoteMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VoteMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vote.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTitle sets the "title" field.
func (m *VoteMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *VoteMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *VoteMutation) ResetTitle() {
	m.title = nil
}

// SetDescription sets the "description" field.
func (m *VoteMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *VoteMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *VoteMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[vote.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *VoteMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[vote.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *VoteMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, vote.FieldDescription)
}

// SetVisible sets the "visible" field.
func (m *VoteMutation) SetVisible(b bool) {
	m.visible = &b
}

// Visible returns the value of the "visible" field in the mutation.
func (m *VoteMutation) Visible() (r bool, exists bool) {
	v := m.visible
	if v == nil {
		return
	}
	return *v, true
}

// OldVisible returns the old "visible" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldVisible(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVisible is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVisible requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVisible: %w", err)
	}
	return oldValue.Visible, nil
}

// ResetVisible resets all changes to the "visible" field.
func (m *VoteMutation) ResetVisible() {
	m.visible = nil
}

// SetStartAt sets the "start_at" field.
func (m *VoteMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *VoteMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *VoteMutation) ResetStartAt() {
	m.start_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *VoteMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *VoteMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *VoteMutation) ResetEndAt() {
	m.end_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *VoteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VoteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VoteMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VoteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VoteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Vote entity.
// If the Vote object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VoteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VoteMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// AddComponentIDs adds the "components" edge to the Component entity by ids.
func (m *VoteMutation) AddComponentIDs(ids ...int) {
	if m.components == nil {
		m.components = make(map[int]struct{})
	}
	for i := range ids {
		m.components[ids[i]] = struct{}{}
	}
}

// ClearComponents clears the "components" edge to the Component entity.
func (m *VoteMutation) ClearComponents() {
	m.clearedcomponents = true
}

// ComponentsCleared reports if the "components" edge to the Component entity was cleared.
func (m *VoteMutation) ComponentsCleared() bool {
	return m.clearedcomponents
}

// RemoveComponentIDs removes the "components" edge to the Component entity by IDs.
func (m *VoteMutation) RemoveComponentIDs(ids ...int) {
	if m.removedcomponents == nil {
		m.removedcomponents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.components, ids[i])
		m.removedcomponents[ids[i]] = struct{}{}
	}
}

// RemovedComponents returns the removed IDs of the "components" edge to the Component entity.
func (m *VoteMutation) RemovedComponentsIDs() (ids []int) {
	for id := range m.removedcomponents {
		ids = append(ids, id)
	}
	return
}

// ComponentsIDs returns the "components" edge IDs in the mutation.
func (m *VoteMutation) ComponentsIDs() (ids []int) {
	for id := range m.components {
		ids = append(ids, id)
	}
	return
}

// ResetComponents resets all changes to the "components" edge.
func (m *VoteMutation) ResetComponents() {
	m.components = nil
	m.clearedcomponents = false
	m.removedcomponents = nil
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *VoteMutation) SetCreatorID(id int) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *VoteMutation) ClearCreator() {
	m.clearedcreator = true
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *VoteMutation) CreatorCleared() bool {
	return m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *VoteMutation) CreatorID() (id int, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *VoteMutation) CreatorIDs() (ids []int) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *VoteMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// Where appends a list predicates to the VoteMutation builder.
func (m *VoteMutation) Where(ps ...predicate.Vote) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the VoteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *VoteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Vote, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *VoteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *VoteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Vote).
func (m *VoteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VoteMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.title != nil {
		fields = append(fields, vote.FieldTitle)
	}
	if m.description != nil {
		fields = append(fields, vote.FieldDescription)
	}
	if m.visible != nil {
		fields = append(fields, vote.FieldVisible)
	}
	if m.start_at != nil {
		fields = append(fields, vote.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, vote.FieldEndAt)
	}
	if m.created_at != nil {
		fields = append(fields, vote.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vote.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VoteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vote.FieldTitle:
		return m.Title()
	case vote.FieldDescription:
		return m.Description()
	case vote.FieldVisible:
		return m.Visible()
	case vote.FieldStartAt:
		return m.StartAt()
	case vote.FieldEndAt:
		return m.EndAt()
	case vote.FieldCreatedAt:
		return m.CreatedAt()
	case vote.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VoteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vote.FieldTitle:
		return m.OldTitle(ctx)
	case vote.FieldDescription:
		return m.OldDescription(ctx)
	case vote.FieldVisible:
		return m.OldVisible(ctx)
	case vote.FieldStartAt:
		return m.OldStartAt(ctx)
	case vote.FieldEndAt:
		return m.OldEndAt(ctx)
	case vote.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vote.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Vote field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vote.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case vote.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case vote.FieldVisible:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVisible(v)
		return nil
	case vote.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case vote.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case vote.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vote.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Vote field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VoteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VoteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VoteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Vote numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VoteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(vote.FieldDescription) {
		fields = append(fields, vote.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VoteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VoteMutation) ClearField(name string) error {
	switch name {
	case vote.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Vote nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VoteMutation) ResetField(name string) error {
	switch name {
	case vote.FieldTitle:
		m.ResetTitle()
		return nil
	case vote.FieldDescription:
		m.ResetDescription()
		return nil
	case vote.FieldVisible:
		m.ResetVisible()
		return nil
	case vote.FieldStartAt:
		m.ResetStartAt()
		return nil
	case vote.FieldEndAt:
		m.ResetEndAt()
		return nil
	case vote.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vote.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Vote field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VoteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.components != nil {
		edges = append(edges, vote.EdgeComponents)
	}
	if m.creator != nil {
		edges = append(edges, vote.EdgeCreator)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VoteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vote.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.components))
		for id := range m.components {
			ids = append(ids, id)
		}
		return ids
	case vote.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VoteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcomponents != nil {
		edges = append(edges, vote.EdgeComponents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VoteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vote.EdgeComponents:
		ids := make([]ent.Value, 0, len(m.removedcomponents))
		for id := range m.removedcomponents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VoteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcomponents {
		edges = append(edges, vote.EdgeComponents)
	}
	if m.clearedcreator {
		edges = append(edges, vote.EdgeCreator)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VoteMutation) EdgeCleared(name string) bool {
	switch name {
	case vote.EdgeComponents:
		return m.clearedcomponents
	case vote.EdgeCreator:
		return m.clearedcreator
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VoteMutation) ClearEdge(name string) error {
	switch name {
	case vote.EdgeCreator:
		m.ClearCreator()
		return nil
	}
	return fmt.Errorf("unknown Vote unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VoteMutation) ResetEdge(name string) error {
	switch name {
	case vote.EdgeComponents:
		m.ResetComponents()
		return nil
	case vote.EdgeCreator:
		m.ResetCreator()
		return nil
	}
	return fmt.Errorf("unknown Vote edge %s", name)
}
